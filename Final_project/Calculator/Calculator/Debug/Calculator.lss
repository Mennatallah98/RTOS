
Calculator.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00001ac2  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000002a  00800060  00001ac2  00001b56  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000002d4  0080008a  0080008a  00001b80  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001b80  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00001bb0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000002f0  00000000  00000000  00001bec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000394c  00000000  00000000  00001edc  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001144  00000000  00000000  00005828  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00001d5c  00000000  00000000  0000696c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000008ac  00000000  00000000  000086c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001076  00000000  00000000  00008f74  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00002aac  00000000  00000000  00009fea  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000002b0  00000000  00000000  0000ca96  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 3a 00 	jmp	0x74	; 0x74 <__ctors_end>
       4:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       8:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
       c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      10:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      14:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      18:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      1c:	0c 94 f8 04 	jmp	0x9f0	; 0x9f0 <__vector_7>
      20:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      24:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      28:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      2c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      30:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      34:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      38:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      3c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      40:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      44:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      48:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      4c:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      50:	0c 94 57 00 	jmp	0xae	; 0xae <__bad_interrupt>
      54:	36 03       	mulsu	r19, r22
      56:	16 03       	mulsu	r17, r22
      58:	18 03       	fmul	r17, r16
      5a:	1a 03       	fmul	r17, r18
      5c:	1c 03       	fmul	r17, r20
      5e:	1e 03       	fmul	r17, r22
      60:	20 03       	mulsu	r18, r16
      62:	22 03       	mulsu	r18, r18
      64:	24 03       	mulsu	r18, r20
      66:	26 03       	mulsu	r18, r22
      68:	28 03       	fmul	r18, r16
      6a:	2a 03       	fmul	r18, r18
      6c:	2c 03       	fmul	r18, r20
      6e:	2e 03       	fmul	r18, r22
      70:	30 03       	mulsu	r19, r16
      72:	32 03       	mulsu	r19, r18

00000074 <__ctors_end>:
      74:	11 24       	eor	r1, r1
      76:	1f be       	out	0x3f, r1	; 63
      78:	cf e5       	ldi	r28, 0x5F	; 95
      7a:	d8 e0       	ldi	r29, 0x08	; 8
      7c:	de bf       	out	0x3e, r29	; 62
      7e:	cd bf       	out	0x3d, r28	; 61

00000080 <__do_copy_data>:
      80:	10 e0       	ldi	r17, 0x00	; 0
      82:	a0 e6       	ldi	r26, 0x60	; 96
      84:	b0 e0       	ldi	r27, 0x00	; 0
      86:	e2 ec       	ldi	r30, 0xC2	; 194
      88:	fa e1       	ldi	r31, 0x1A	; 26
      8a:	02 c0       	rjmp	.+4      	; 0x90 <__do_copy_data+0x10>
      8c:	05 90       	lpm	r0, Z+
      8e:	0d 92       	st	X+, r0
      90:	aa 38       	cpi	r26, 0x8A	; 138
      92:	b1 07       	cpc	r27, r17
      94:	d9 f7       	brne	.-10     	; 0x8c <__do_copy_data+0xc>

00000096 <__do_clear_bss>:
      96:	23 e0       	ldi	r18, 0x03	; 3
      98:	aa e8       	ldi	r26, 0x8A	; 138
      9a:	b0 e0       	ldi	r27, 0x00	; 0
      9c:	01 c0       	rjmp	.+2      	; 0xa0 <.do_clear_bss_start>

0000009e <.do_clear_bss_loop>:
      9e:	1d 92       	st	X+, r1

000000a0 <.do_clear_bss_start>:
      a0:	ae 35       	cpi	r26, 0x5E	; 94
      a2:	b2 07       	cpc	r27, r18
      a4:	e1 f7       	brne	.-8      	; 0x9e <.do_clear_bss_loop>
      a6:	0e 94 a6 01 	call	0x34c	; 0x34c <main>
      aa:	0c 94 5f 0d 	jmp	0x1abe	; 0x1abe <_exit>

000000ae <__bad_interrupt>:
      ae:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000b2 <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      b2:	cf 93       	push	r28
      b4:	df 93       	push	r29
      b6:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      b8:	0e 94 10 09 	call	0x1220	; 0x1220 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      bc:	20 91 8a 00 	lds	r18, 0x008A	; 0x80008a <__data_end>
      c0:	30 91 8b 00 	lds	r19, 0x008B	; 0x80008b <__data_end+0x1>
      c4:	c9 01       	movw	r24, r18
      c6:	8c 0f       	add	r24, r28
      c8:	9d 1f       	adc	r25, r29
      ca:	88 35       	cpi	r24, 0x58	; 88
      cc:	42 e0       	ldi	r20, 0x02	; 2
      ce:	94 07       	cpc	r25, r20
      d0:	58 f4       	brcc	.+22     	; 0xe8 <pvPortMalloc+0x36>
      d2:	28 17       	cp	r18, r24
      d4:	39 07       	cpc	r19, r25
      d6:	58 f4       	brcc	.+22     	; 0xee <pvPortMalloc+0x3c>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      d8:	e9 01       	movw	r28, r18
      da:	c4 57       	subi	r28, 0x74	; 116
      dc:	df 4f       	sbci	r29, 0xFF	; 255
			xNextFreeByte += xWantedSize;			
      de:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__data_end+0x1>
      e2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__data_end>
      e6:	05 c0       	rjmp	.+10     	; 0xf2 <pvPortMalloc+0x40>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
      e8:	c0 e0       	ldi	r28, 0x00	; 0
      ea:	d0 e0       	ldi	r29, 0x00	; 0
      ec:	02 c0       	rjmp	.+4      	; 0xf2 <pvPortMalloc+0x40>
      ee:	c0 e0       	ldi	r28, 0x00	; 0
      f0:	d0 e0       	ldi	r29, 0x00	; 0
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
      f2:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
		}
	}
	#endif	

	return pvReturn;
}
      f6:	ce 01       	movw	r24, r28
      f8:	df 91       	pop	r29
      fa:	cf 91       	pop	r28
      fc:	08 95       	ret

000000fe <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
      fe:	08 95       	ret

00000100 <enableTrigger>:
//   data changes.
////////////////////////////////////////////////////////////////////
void enableTrigger(void)
{

	CLR_BIT(PORTB,2);
     100:	c2 98       	cbi	0x18, 2	; 24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     102:	89 ef       	ldi	r24, 0xF9	; 249
     104:	90 e0       	ldi	r25, 0x00	; 0
     106:	01 97       	sbiw	r24, 0x01	; 1
     108:	f1 f7       	brne	.-4      	; 0x106 <enableTrigger+0x6>
     10a:	00 c0       	rjmp	.+0      	; 0x10c <enableTrigger+0xc>
     10c:	00 00       	nop
	
	_delay_ms(1);

	SET_BIT(PORTB,2);
     10e:	c2 9a       	sbi	0x18, 2	; 24
     110:	8b ed       	ldi	r24, 0xDB	; 219
     112:	95 e0       	ldi	r25, 0x05	; 5
     114:	01 97       	sbiw	r24, 0x01	; 1
     116:	f1 f7       	brne	.-4      	; 0x114 <enableTrigger+0x14>
     118:	00 c0       	rjmp	.+0      	; 0x11a <enableTrigger+0x1a>
     11a:	00 00       	nop
     11c:	08 95       	ret

0000011e <lcd_sendCommand>:
		
}


void lcd_sendCommand(unsigned char cmd)
{
     11e:	cf 93       	push	r28
     120:	c8 2f       	mov	r28, r24
	unsigned char high_nibble , low_nibble ; 		
	
	HIGH_NIBBLE(high_nibble,cmd);
	LOW_NIBBLE(low_nibble,cmd);

	CLR_BIT(PORTB,0); // to enable command mode 
     122:	c0 98       	cbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // write signal to lcd 
     124:	c1 98       	cbi	0x18, 1	; 24

	PORTB &=0x0f;
     126:	88 b3       	in	r24, 0x18	; 24
     128:	8f 70       	andi	r24, 0x0F	; 15
     12a:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble command  
     12c:	88 b3       	in	r24, 0x18	; 24
     12e:	9c 2f       	mov	r25, r28
     130:	90 7f       	andi	r25, 0xF0	; 240
     132:	89 2b       	or	r24, r25
     134:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     136:	0e 94 80 00 	call	0x100	; 0x100 <enableTrigger>

	PORTB &=0x0f;
     13a:	88 b3       	in	r24, 0x18	; 24
     13c:	8f 70       	andi	r24, 0x0F	; 15
     13e:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble command 
     140:	88 b3       	in	r24, 0x18	; 24
     142:	c2 95       	swap	r28
     144:	c0 7f       	andi	r28, 0xF0	; 240
     146:	c8 2b       	or	r28, r24
     148:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     14a:	0e 94 80 00 	call	0x100	; 0x100 <enableTrigger>

}
     14e:	cf 91       	pop	r28
     150:	08 95       	ret

00000152 <lcd_init>:
//							 and pinB.0 to pinB.2 o/p for control pins 
//////////////////////////////////////////////////////////////////////////////////////
void lcd_init(void)
{

	DDRB=0xff; // init port B as O/P port 
     152:	8f ef       	ldi	r24, 0xFF	; 255
     154:	87 bb       	out	0x17, r24	; 23
	PORTB=0x04; // activate LCD enable 
     156:	84 e0       	ldi	r24, 0x04	; 4
     158:	88 bb       	out	0x18, r24	; 24

	lcd_sendCommand(0x33); // 4-bit mode 
     15a:	83 e3       	ldi	r24, 0x33	; 51
     15c:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_sendCommand>
	lcd_sendCommand (0x32);
     160:	82 e3       	ldi	r24, 0x32	; 50
     162:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_sendCommand>
	lcd_sendCommand (0x28);
     166:	88 e2       	ldi	r24, 0x28	; 40
     168:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_sendCommand>



	lcd_sendCommand(0x0c); // turn on lcd 
     16c:	8c e0       	ldi	r24, 0x0C	; 12
     16e:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_sendCommand>
     172:	08 95       	ret

00000174 <lcd_displayChar>:
	enableTrigger();

}

void lcd_displayChar (unsigned char data)
{
     174:	cf 93       	push	r28
     176:	c8 2f       	mov	r28, r24

	unsigned char high_nibble , low_nibble ;

	SET_BIT(PORTB,0); //  enable data mode 
     178:	c0 9a       	sbi	0x18, 0	; 24
	CLR_BIT(PORTB,1); // activate lcd write 
     17a:	c1 98       	cbi	0x18, 1	; 24

	HIGH_NIBBLE(high_nibble,data); // get high nibble data 
	LOW_NIBBLE(low_nibble,data); // get low nibble data 
	
	PORTB &= 0x0f;
     17c:	88 b3       	in	r24, 0x18	; 24
     17e:	8f 70       	andi	r24, 0x0F	; 15
     180:	88 bb       	out	0x18, r24	; 24
	PORTB |=high_nibble;// to send high nibble data  
     182:	88 b3       	in	r24, 0x18	; 24
     184:	9c 2f       	mov	r25, r28
     186:	90 7f       	andi	r25, 0xF0	; 240
     188:	89 2b       	or	r24, r25
     18a:	88 bb       	out	0x18, r24	; 24
	enableTrigger(); // triggre lcd enable 
     18c:	0e 94 80 00 	call	0x100	; 0x100 <enableTrigger>
	
	PORTB &=0x0f;
     190:	88 b3       	in	r24, 0x18	; 24
     192:	8f 70       	andi	r24, 0x0F	; 15
     194:	88 bb       	out	0x18, r24	; 24
	PORTB |=low_nibble; // to send low nibble data 
     196:	88 b3       	in	r24, 0x18	; 24
     198:	c2 95       	swap	r28
     19a:	c0 7f       	andi	r28, 0xF0	; 240
     19c:	c8 2b       	or	r28, r24
     19e:	c8 bb       	out	0x18, r28	; 24
	enableTrigger();
     1a0:	0e 94 80 00 	call	0x100	; 0x100 <enableTrigger>
	

}
     1a4:	cf 91       	pop	r28
     1a6:	08 95       	ret

000001a8 <lcd_gotoxy>:

void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
	 
	switch(y)
     1a8:	81 30       	cpi	r24, 0x01	; 1
     1aa:	49 f0       	breq	.+18     	; 0x1be <lcd_gotoxy+0x16>
     1ac:	28 f0       	brcs	.+10     	; 0x1b8 <lcd_gotoxy+0x10>
     1ae:	82 30       	cpi	r24, 0x02	; 2
     1b0:	49 f0       	breq	.+18     	; 0x1c4 <lcd_gotoxy+0x1c>
     1b2:	83 30       	cpi	r24, 0x03	; 3
     1b4:	51 f0       	breq	.+20     	; 0x1ca <lcd_gotoxy+0x22>
     1b6:	0c c0       	rjmp	.+24     	; 0x1d0 <lcd_gotoxy+0x28>
	{
		case 0:

			position=position+x;
     1b8:	80 e8       	ldi	r24, 0x80	; 128
     1ba:	86 0f       	add	r24, r22
					
		break;
     1bc:	0a c0       	rjmp	.+20     	; 0x1d2 <lcd_gotoxy+0x2a>

		case 1:

			position=0xc0;
			position=position+x;
     1be:	80 ec       	ldi	r24, 0xC0	; 192
     1c0:	86 0f       	add	r24, r22

		break;
     1c2:	07 c0       	rjmp	.+14     	; 0x1d2 <lcd_gotoxy+0x2a>

		case 2:

			position=position+x;
     1c4:	80 e8       	ldi	r24, 0x80	; 128
     1c6:	86 0f       	add	r24, r22

		break;
     1c8:	04 c0       	rjmp	.+8      	; 0x1d2 <lcd_gotoxy+0x2a>

		case 3:
			position=position+x;
     1ca:	80 e8       	ldi	r24, 0x80	; 128
     1cc:	86 0f       	add	r24, r22
		break;
     1ce:	01 c0       	rjmp	.+2      	; 0x1d2 <lcd_gotoxy+0x2a>
}


void lcd_gotoxy(unsigned char y , unsigned char x )
{
	unsigned char position = 0x80;
     1d0:	80 e8       	ldi	r24, 0x80	; 128
		break;
	
	
	}
	
	lcd_sendCommand(position); 	
     1d2:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_sendCommand>
     1d6:	08 95       	ret

000001d8 <lcd_clrScreen>:


void lcd_clrScreen(void)
{

	lcd_sendCommand(0x01);
     1d8:	81 e0       	ldi	r24, 0x01	; 1
     1da:	0e 94 8f 00 	call	0x11e	; 0x11e <lcd_sendCommand>
     1de:	08 95       	ret

000001e0 <lcd_dispString>:

}


void lcd_dispString(char * ptr)
{
     1e0:	cf 93       	push	r28
     1e2:	df 93       	push	r29
     1e4:	ec 01       	movw	r28, r24

	while(* ptr!= '\0')
     1e6:	88 81       	ld	r24, Y
     1e8:	88 23       	and	r24, r24
     1ea:	31 f0       	breq	.+12     	; 0x1f8 <lcd_dispString+0x18>
     1ec:	21 96       	adiw	r28, 0x01	; 1
	{
		lcd_displayChar(* ptr);
     1ee:	0e 94 ba 00 	call	0x174	; 0x174 <lcd_displayChar>


void lcd_dispString(char * ptr)
{

	while(* ptr!= '\0')
     1f2:	89 91       	ld	r24, Y+
     1f4:	81 11       	cpse	r24, r1
     1f6:	fb cf       	rjmp	.-10     	; 0x1ee <lcd_dispString+0xe>
	
	}



}
     1f8:	df 91       	pop	r29
     1fa:	cf 91       	pop	r28
     1fc:	08 95       	ret

000001fe <lcd_disp_string_xy>:

void lcd_disp_string_xy(char * ptr , int y , int x)
{
     1fe:	cf 93       	push	r28
     200:	df 93       	push	r29
     202:	ec 01       	movw	r28, r24
     204:	86 2f       	mov	r24, r22

	lcd_gotoxy(y,x);
     206:	64 2f       	mov	r22, r20
     208:	0e 94 d4 00 	call	0x1a8	; 0x1a8 <lcd_gotoxy>
	lcd_dispString(ptr);
     20c:	ce 01       	movw	r24, r28
     20e:	0e 94 f0 00 	call	0x1e0	; 0x1e0 <lcd_dispString>

	


}
     212:	df 91       	pop	r29
     214:	cf 91       	pop	r28
     216:	08 95       	ret

00000218 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     218:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     21a:	03 96       	adiw	r24, 0x03	; 3
     21c:	92 83       	std	Z+2, r25	; 0x02
     21e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     220:	2f ef       	ldi	r18, 0xFF	; 255
     222:	3f ef       	ldi	r19, 0xFF	; 255
     224:	34 83       	std	Z+4, r19	; 0x04
     226:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     228:	96 83       	std	Z+6, r25	; 0x06
     22a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     22c:	90 87       	std	Z+8, r25	; 0x08
     22e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     230:	10 82       	st	Z, r1
     232:	08 95       	ret

00000234 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     234:	fc 01       	movw	r30, r24
     236:	11 86       	std	Z+9, r1	; 0x09
     238:	10 86       	std	Z+8, r1	; 0x08
     23a:	08 95       	ret

0000023c <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     23c:	cf 93       	push	r28
     23e:	df 93       	push	r29
     240:	fc 01       	movw	r30, r24
     242:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     244:	21 81       	ldd	r18, Z+1	; 0x01
     246:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     248:	e9 01       	movw	r28, r18
     24a:	8a 81       	ldd	r24, Y+2	; 0x02
     24c:	9b 81       	ldd	r25, Y+3	; 0x03
     24e:	13 96       	adiw	r26, 0x03	; 3
     250:	9c 93       	st	X, r25
     252:	8e 93       	st	-X, r24
     254:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     256:	81 81       	ldd	r24, Z+1	; 0x01
     258:	92 81       	ldd	r25, Z+2	; 0x02
     25a:	15 96       	adiw	r26, 0x05	; 5
     25c:	9c 93       	st	X, r25
     25e:	8e 93       	st	-X, r24
     260:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     262:	8a 81       	ldd	r24, Y+2	; 0x02
     264:	9b 81       	ldd	r25, Y+3	; 0x03
     266:	ec 01       	movw	r28, r24
     268:	7d 83       	std	Y+5, r23	; 0x05
     26a:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     26c:	e9 01       	movw	r28, r18
     26e:	7b 83       	std	Y+3, r23	; 0x03
     270:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     272:	72 83       	std	Z+2, r23	; 0x02
     274:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     276:	19 96       	adiw	r26, 0x09	; 9
     278:	fc 93       	st	X, r31
     27a:	ee 93       	st	-X, r30
     27c:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     27e:	80 81       	ld	r24, Z
     280:	8f 5f       	subi	r24, 0xFF	; 255
     282:	80 83       	st	Z, r24
}
     284:	df 91       	pop	r29
     286:	cf 91       	pop	r28
     288:	08 95       	ret

0000028a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     28a:	cf 93       	push	r28
     28c:	df 93       	push	r29
     28e:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     290:	48 81       	ld	r20, Y
     292:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     294:	4f 3f       	cpi	r20, 0xFF	; 255
     296:	2f ef       	ldi	r18, 0xFF	; 255
     298:	52 07       	cpc	r21, r18
     29a:	31 f4       	brne	.+12     	; 0x2a8 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     29c:	dc 01       	movw	r26, r24
     29e:	17 96       	adiw	r26, 0x07	; 7
     2a0:	ed 91       	ld	r30, X+
     2a2:	fc 91       	ld	r31, X
     2a4:	18 97       	sbiw	r26, 0x08	; 8
     2a6:	17 c0       	rjmp	.+46     	; 0x2d6 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     2a8:	fc 01       	movw	r30, r24
     2aa:	33 96       	adiw	r30, 0x03	; 3
     2ac:	dc 01       	movw	r26, r24
     2ae:	15 96       	adiw	r26, 0x05	; 5
     2b0:	2d 91       	ld	r18, X+
     2b2:	3c 91       	ld	r19, X
     2b4:	16 97       	sbiw	r26, 0x06	; 6
     2b6:	d9 01       	movw	r26, r18
     2b8:	2d 91       	ld	r18, X+
     2ba:	3c 91       	ld	r19, X
     2bc:	42 17       	cp	r20, r18
     2be:	53 07       	cpc	r21, r19
     2c0:	50 f0       	brcs	.+20     	; 0x2d6 <vListInsert+0x4c>
     2c2:	02 80       	ldd	r0, Z+2	; 0x02
     2c4:	f3 81       	ldd	r31, Z+3	; 0x03
     2c6:	e0 2d       	mov	r30, r0
     2c8:	a2 81       	ldd	r26, Z+2	; 0x02
     2ca:	b3 81       	ldd	r27, Z+3	; 0x03
     2cc:	2d 91       	ld	r18, X+
     2ce:	3c 91       	ld	r19, X
     2d0:	42 17       	cp	r20, r18
     2d2:	53 07       	cpc	r21, r19
     2d4:	b0 f7       	brcc	.-20     	; 0x2c2 <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2d6:	a2 81       	ldd	r26, Z+2	; 0x02
     2d8:	b3 81       	ldd	r27, Z+3	; 0x03
     2da:	bb 83       	std	Y+3, r27	; 0x03
     2dc:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     2de:	15 96       	adiw	r26, 0x05	; 5
     2e0:	dc 93       	st	X, r29
     2e2:	ce 93       	st	-X, r28
     2e4:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     2e6:	fd 83       	std	Y+5, r31	; 0x05
     2e8:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     2ea:	d3 83       	std	Z+3, r29	; 0x03
     2ec:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2ee:	99 87       	std	Y+9, r25	; 0x09
     2f0:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2f2:	fc 01       	movw	r30, r24
     2f4:	20 81       	ld	r18, Z
     2f6:	2f 5f       	subi	r18, 0xFF	; 255
     2f8:	20 83       	st	Z, r18
}
     2fa:	df 91       	pop	r29
     2fc:	cf 91       	pop	r28
     2fe:	08 95       	ret

00000300 <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     300:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     302:	a2 81       	ldd	r26, Z+2	; 0x02
     304:	b3 81       	ldd	r27, Z+3	; 0x03
     306:	84 81       	ldd	r24, Z+4	; 0x04
     308:	95 81       	ldd	r25, Z+5	; 0x05
     30a:	15 96       	adiw	r26, 0x05	; 5
     30c:	9c 93       	st	X, r25
     30e:	8e 93       	st	-X, r24
     310:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     312:	a4 81       	ldd	r26, Z+4	; 0x04
     314:	b5 81       	ldd	r27, Z+5	; 0x05
     316:	82 81       	ldd	r24, Z+2	; 0x02
     318:	93 81       	ldd	r25, Z+3	; 0x03
     31a:	13 96       	adiw	r26, 0x03	; 3
     31c:	9c 93       	st	X, r25
     31e:	8e 93       	st	-X, r24
     320:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     322:	a0 85       	ldd	r26, Z+8	; 0x08
     324:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     326:	11 96       	adiw	r26, 0x01	; 1
     328:	8d 91       	ld	r24, X+
     32a:	9c 91       	ld	r25, X
     32c:	12 97       	sbiw	r26, 0x02	; 2
     32e:	e8 17       	cp	r30, r24
     330:	f9 07       	cpc	r31, r25
     332:	31 f4       	brne	.+12     	; 0x340 <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     334:	84 81       	ldd	r24, Z+4	; 0x04
     336:	95 81       	ldd	r25, Z+5	; 0x05
     338:	12 96       	adiw	r26, 0x02	; 2
     33a:	9c 93       	st	X, r25
     33c:	8e 93       	st	-X, r24
     33e:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     340:	11 86       	std	Z+9, r1	; 0x09
     342:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     344:	8c 91       	ld	r24, X
     346:	81 50       	subi	r24, 0x01	; 1
     348:	8c 93       	st	X, r24
     34a:	08 95       	ret

0000034c <main>:
	PORTB &= 0xF7;
	
}

void LedRising(void)
{
     34c:	af 92       	push	r10
     34e:	bf 92       	push	r11
     350:	cf 92       	push	r12
     352:	df 92       	push	r13
     354:	ef 92       	push	r14
     356:	ff 92       	push	r15
     358:	0f 93       	push	r16
     35a:	0e 94 a9 00 	call	0x152	; 0x152 <lcd_init>
     35e:	8f ef       	ldi	r24, 0xFF	; 255
     360:	87 bb       	out	0x17, r24	; 23
     362:	a1 2c       	mov	r10, r1
     364:	b1 2c       	mov	r11, r1
     366:	c1 2c       	mov	r12, r1
     368:	d1 2c       	mov	r13, r1
     36a:	0f 2e       	mov	r0, r31
     36c:	fa e5       	ldi	r31, 0x5A	; 90
     36e:	ef 2e       	mov	r14, r31
     370:	f3 e0       	ldi	r31, 0x03	; 3
     372:	ff 2e       	mov	r15, r31
     374:	f0 2d       	mov	r31, r0
     376:	03 e0       	ldi	r16, 0x03	; 3
     378:	20 e0       	ldi	r18, 0x00	; 0
     37a:	30 e0       	ldi	r19, 0x00	; 0
     37c:	44 e6       	ldi	r20, 0x64	; 100
     37e:	50 e0       	ldi	r21, 0x00	; 0
     380:	60 e0       	ldi	r22, 0x00	; 0
     382:	70 e0       	ldi	r23, 0x00	; 0
     384:	8f e4       	ldi	r24, 0x4F	; 79
     386:	92 e0       	ldi	r25, 0x02	; 2
     388:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xTaskGenericCreate>
     38c:	0f 2e       	mov	r0, r31
     38e:	fc e5       	ldi	r31, 0x5C	; 92
     390:	ef 2e       	mov	r14, r31
     392:	f3 e0       	ldi	r31, 0x03	; 3
     394:	ff 2e       	mov	r15, r31
     396:	f0 2d       	mov	r31, r0
     398:	02 e0       	ldi	r16, 0x02	; 2
     39a:	20 e0       	ldi	r18, 0x00	; 0
     39c:	30 e0       	ldi	r19, 0x00	; 0
     39e:	44 e6       	ldi	r20, 0x64	; 100
     3a0:	50 e0       	ldi	r21, 0x00	; 0
     3a2:	60 e0       	ldi	r22, 0x00	; 0
     3a4:	70 e0       	ldi	r23, 0x00	; 0
     3a6:	80 ea       	ldi	r24, 0xA0	; 160
     3a8:	93 e0       	ldi	r25, 0x03	; 3
     3aa:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xTaskGenericCreate>
     3ae:	0f 2e       	mov	r0, r31
     3b0:	f4 e5       	ldi	r31, 0x54	; 84
     3b2:	ef 2e       	mov	r14, r31
     3b4:	f3 e0       	ldi	r31, 0x03	; 3
     3b6:	ff 2e       	mov	r15, r31
     3b8:	f0 2d       	mov	r31, r0
     3ba:	01 e0       	ldi	r16, 0x01	; 1
     3bc:	20 e0       	ldi	r18, 0x00	; 0
     3be:	30 e0       	ldi	r19, 0x00	; 0
     3c0:	44 e6       	ldi	r20, 0x64	; 100
     3c2:	50 e0       	ldi	r21, 0x00	; 0
     3c4:	60 e0       	ldi	r22, 0x00	; 0
     3c6:	70 e0       	ldi	r23, 0x00	; 0
     3c8:	83 ec       	ldi	r24, 0xC3	; 195
     3ca:	92 e0       	ldi	r25, 0x02	; 2
     3cc:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xTaskGenericCreate>
     3d0:	60 e0       	ldi	r22, 0x00	; 0
     3d2:	81 e0       	ldi	r24, 0x01	; 1
     3d4:	0e 94 c1 05 	call	0xb82	; 0xb82 <xQueueCreate>
     3d8:	90 93 57 03 	sts	0x0357, r25	; 0x800357 <xSemaphore+0x1>
     3dc:	80 93 56 03 	sts	0x0356, r24	; 0x800356 <xSemaphore>
     3e0:	00 97       	sbiw	r24, 0x00	; 0
     3e2:	39 f0       	breq	.+14     	; 0x3f2 <main+0xa6>
     3e4:	20 e0       	ldi	r18, 0x00	; 0
     3e6:	40 e0       	ldi	r20, 0x00	; 0
     3e8:	50 e0       	ldi	r21, 0x00	; 0
     3ea:	60 e0       	ldi	r22, 0x00	; 0
     3ec:	70 e0       	ldi	r23, 0x00	; 0
     3ee:	0e 94 11 06 	call	0xc22	; 0xc22 <xQueueGenericSend>
     3f2:	0e 94 e5 08 	call	0x11ca	; 0x11ca <vTaskStartScheduler>
     3f6:	80 e0       	ldi	r24, 0x00	; 0
     3f8:	90 e0       	ldi	r25, 0x00	; 0
     3fa:	0f 91       	pop	r16
     3fc:	ff 90       	pop	r15
     3fe:	ef 90       	pop	r14
     400:	df 90       	pop	r13
     402:	cf 90       	pop	r12
     404:	bf 90       	pop	r11
     406:	af 90       	pop	r10
     408:	08 95       	ret

0000040a <LcdWrite_move>:
     40a:	40 91 e6 02 	lds	r20, 0x02E6	; 0x8002e6 <x>
     40e:	50 91 e7 02 	lds	r21, 0x02E7	; 0x8002e7 <x+0x1>
     412:	60 e0       	ldi	r22, 0x00	; 0
     414:	70 e0       	ldi	r23, 0x00	; 0
     416:	82 e6       	ldi	r24, 0x62	; 98
     418:	90 e0       	ldi	r25, 0x00	; 0
     41a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <lcd_disp_string_xy>
     41e:	80 91 e6 02 	lds	r24, 0x02E6	; 0x8002e6 <x>
     422:	90 91 e7 02 	lds	r25, 0x02E7	; 0x8002e7 <x+0x1>
     426:	00 97       	sbiw	r24, 0x00	; 0
     428:	a1 f4       	brne	.+40     	; 0x452 <LcdWrite_move+0x48>
     42a:	10 92 59 03 	sts	0x0359, r1	; 0x800359 <direction+0x1>
     42e:	10 92 58 03 	sts	0x0358, r1	; 0x800358 <direction>
     432:	81 e0       	ldi	r24, 0x01	; 1
     434:	90 e0       	ldi	r25, 0x00	; 0
     436:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <x+0x1>
     43a:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <x>
     43e:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <counter>
     442:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <counter+0x1>
     446:	01 96       	adiw	r24, 0x01	; 1
     448:	90 93 e5 02 	sts	0x02E5, r25	; 0x8002e5 <counter+0x1>
     44c:	80 93 e4 02 	sts	0x02E4, r24	; 0x8002e4 <counter>
     450:	08 95       	ret
     452:	89 30       	cpi	r24, 0x09	; 9
     454:	91 05       	cpc	r25, r1
     456:	69 f4       	brne	.+26     	; 0x472 <LcdWrite_move+0x68>
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	90 e0       	ldi	r25, 0x00	; 0
     45c:	90 93 59 03 	sts	0x0359, r25	; 0x800359 <direction+0x1>
     460:	80 93 58 03 	sts	0x0358, r24	; 0x800358 <direction>
     464:	88 e0       	ldi	r24, 0x08	; 8
     466:	90 e0       	ldi	r25, 0x00	; 0
     468:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <x+0x1>
     46c:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <x>
     470:	08 95       	ret
     472:	20 91 58 03 	lds	r18, 0x0358	; 0x800358 <direction>
     476:	30 91 59 03 	lds	r19, 0x0359	; 0x800359 <direction+0x1>
     47a:	21 15       	cp	r18, r1
     47c:	31 05       	cpc	r19, r1
     47e:	31 f4       	brne	.+12     	; 0x48c <LcdWrite_move+0x82>
     480:	01 96       	adiw	r24, 0x01	; 1
     482:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <x+0x1>
     486:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <x>
     48a:	08 95       	ret
     48c:	21 30       	cpi	r18, 0x01	; 1
     48e:	31 05       	cpc	r19, r1
     490:	29 f4       	brne	.+10     	; 0x49c <LcdWrite_move+0x92>
     492:	01 97       	sbiw	r24, 0x01	; 1
     494:	90 93 e7 02 	sts	0x02E7, r25	; 0x8002e7 <x+0x1>
     498:	80 93 e6 02 	sts	0x02E6, r24	; 0x8002e6 <x>
     49c:	08 95       	ret

0000049e <period_lcd_welcome>:
     49e:	cf 93       	push	r28
     4a0:	df 93       	push	r29
     4a2:	00 d0       	rcall	.+0      	; 0x4a4 <period_lcd_welcome+0x6>
     4a4:	cd b7       	in	r28, 0x3d	; 61
     4a6:	de b7       	in	r29, 0x3e	; 62
     4a8:	0e 94 16 09 	call	0x122c	; 0x122c <xTaskGetTickCount>
     4ac:	9a 83       	std	Y+2, r25	; 0x02
     4ae:	89 83       	std	Y+1, r24	; 0x01
     4b0:	20 e0       	ldi	r18, 0x00	; 0
     4b2:	4f ef       	ldi	r20, 0xFF	; 255
     4b4:	5f ef       	ldi	r21, 0xFF	; 255
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     4be:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     4c2:	0e 94 ab 06 	call	0xd56	; 0xd56 <xQueueGenericReceive>
     4c6:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <counter>
     4ca:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <counter+0x1>
     4ce:	04 97       	sbiw	r24, 0x04	; 4
     4d0:	84 f4       	brge	.+32     	; 0x4f2 <period_lcd_welcome+0x54>
     4d2:	69 e1       	ldi	r22, 0x19	; 25
     4d4:	70 e0       	ldi	r23, 0x00	; 0
     4d6:	ce 01       	movw	r24, r28
     4d8:	01 96       	adiw	r24, 0x01	; 1
     4da:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
     4de:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <lcd_clrScreen>
     4e2:	0e 94 05 02 	call	0x40a	; 0x40a <LcdWrite_move>
     4e6:	80 91 e4 02 	lds	r24, 0x02E4	; 0x8002e4 <counter>
     4ea:	90 91 e5 02 	lds	r25, 0x02E5	; 0x8002e5 <counter+0x1>
     4ee:	04 97       	sbiw	r24, 0x04	; 4
     4f0:	84 f3       	brlt	.-32     	; 0x4d2 <period_lcd_welcome+0x34>
     4f2:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <lcd_clrScreen>
     4f6:	20 e0       	ldi	r18, 0x00	; 0
     4f8:	40 e0       	ldi	r20, 0x00	; 0
     4fa:	50 e0       	ldi	r21, 0x00	; 0
     4fc:	60 e0       	ldi	r22, 0x00	; 0
     4fe:	70 e0       	ldi	r23, 0x00	; 0
     500:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     504:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     508:	0e 94 11 06 	call	0xc22	; 0xc22 <xQueueGenericSend>
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	0e 94 9c 08 	call	0x1138	; 0x1138 <vTaskDelete>
     514:	0f 90       	pop	r0
     516:	0f 90       	pop	r0
     518:	df 91       	pop	r29
     51a:	cf 91       	pop	r28
     51c:	08 95       	ret

0000051e <LcdWrite_blink>:
     51e:	40 e0       	ldi	r20, 0x00	; 0
     520:	50 e0       	ldi	r21, 0x00	; 0
     522:	60 e0       	ldi	r22, 0x00	; 0
     524:	70 e0       	ldi	r23, 0x00	; 0
     526:	8a e6       	ldi	r24, 0x6A	; 106
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <lcd_disp_string_xy>
     52e:	44 e0       	ldi	r20, 0x04	; 4
     530:	50 e0       	ldi	r21, 0x00	; 0
     532:	61 e0       	ldi	r22, 0x01	; 1
     534:	70 e0       	ldi	r23, 0x00	; 0
     536:	8c e7       	ldi	r24, 0x7C	; 124
     538:	90 e0       	ldi	r25, 0x00	; 0
     53a:	0e 94 ff 00 	call	0x1fe	; 0x1fe <lcd_disp_string_xy>
     53e:	08 95       	ret

00000540 <LedHigh>:
     540:	c3 9a       	sbi	0x18, 3	; 24
     542:	08 95       	ret

00000544 <LedLow>:
     544:	c3 98       	cbi	0x18, 3	; 24
     546:	08 95       	ret

00000548 <LedFalling>:
		_delay_ms(25);		
	}	
}

void LedFalling(void)
{
     548:	cf 93       	push	r28
     54a:	df 93       	push	r29
	int x;
	for(x=10;x--;x>=0)
     54c:	c9 e0       	ldi	r28, 0x09	; 9
     54e:	d0 e0       	ldi	r29, 0x00	; 0
	{
		OCR0 = 25.5*x;
     550:	be 01       	movw	r22, r28
     552:	0d 2e       	mov	r0, r29
     554:	00 0c       	add	r0, r0
     556:	88 0b       	sbc	r24, r24
     558:	99 0b       	sbc	r25, r25
     55a:	0e 94 41 0c 	call	0x1882	; 0x1882 <__floatsisf>
     55e:	20 e0       	ldi	r18, 0x00	; 0
     560:	30 e0       	ldi	r19, 0x00	; 0
     562:	4c ec       	ldi	r20, 0xCC	; 204
     564:	51 e4       	ldi	r21, 0x41	; 65
     566:	0e 94 a5 0c 	call	0x194a	; 0x194a <__mulsf3>
     56a:	0e 94 10 0c 	call	0x1820	; 0x1820 <__fixunssfsi>
     56e:	6c bf       	out	0x3c, r22	; 60
     570:	8f e4       	ldi	r24, 0x4F	; 79
     572:	93 ec       	ldi	r25, 0xC3	; 195
     574:	01 97       	sbiw	r24, 0x01	; 1
     576:	f1 f7       	brne	.-4      	; 0x574 <LedFalling+0x2c>
     578:	00 c0       	rjmp	.+0      	; 0x57a <LedFalling+0x32>
     57a:	00 00       	nop
}

void LedFalling(void)
{
	int x;
	for(x=10;x--;x>=0)
     57c:	21 97       	sbiw	r28, 0x01	; 1
     57e:	40 f7       	brcc	.-48     	; 0x550 <LedFalling+0x8>
	{
		OCR0 = 25.5*x;
		_delay_ms(25);
	}
}
     580:	df 91       	pop	r29
     582:	cf 91       	pop	r28
     584:	08 95       	ret

00000586 <period_blinking>:
	xSemaphoreGive(xSemaphore);
	vTaskDelete(NULL);
}

void period_blinking(void *p)
{
     586:	cf 93       	push	r28
     588:	df 93       	push	r29
     58a:	00 d0       	rcall	.+0      	; 0x58c <period_blinking+0x6>
     58c:	cd b7       	in	r28, 0x3d	; 61
     58e:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	const portTickType xPeriod = 250;
	const portTickType time = portMAX_DELAY;
	xLastWakeTime = xTaskGetTickCount();
     590:	0e 94 16 09 	call	0x122c	; 0x122c <xTaskGetTickCount>
     594:	9a 83       	std	Y+2, r25	; 0x02
     596:	89 83       	std	Y+1, r24	; 0x01
	if(xSemaphoreTake(xSemaphore,time)==pdTRUE)
     598:	20 e0       	ldi	r18, 0x00	; 0
     59a:	4f ef       	ldi	r20, 0xFF	; 255
     59c:	5f ef       	ldi	r21, 0xFF	; 255
     59e:	60 e0       	ldi	r22, 0x00	; 0
     5a0:	70 e0       	ldi	r23, 0x00	; 0
     5a2:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     5a6:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     5aa:	0e 94 ab 06 	call	0xd56	; 0xd56 <xQueueGenericReceive>
     5ae:	81 30       	cpi	r24, 0x01	; 1
     5b0:	f9 f4       	brne	.+62     	; 0x5f0 <period_blinking+0x6a>
	{
		while(1)
		{
			LedRising();
			vTaskDelayUntil( &xLastWakeTime, xPeriod);			
     5b2:	6a ef       	ldi	r22, 0xFA	; 250
     5b4:	70 e0       	ldi	r23, 0x00	; 0
     5b6:	ce 01       	movw	r24, r28
     5b8:	01 96       	adiw	r24, 0x01	; 1
     5ba:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
			LedHigh();
     5be:	0e 94 a0 02 	call	0x540	; 0x540 <LedHigh>
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
     5c2:	6a ef       	ldi	r22, 0xFA	; 250
     5c4:	70 e0       	ldi	r23, 0x00	; 0
     5c6:	ce 01       	movw	r24, r28
     5c8:	01 96       	adiw	r24, 0x01	; 1
     5ca:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
			LedFalling();
     5ce:	0e 94 a4 02 	call	0x548	; 0x548 <LedFalling>
			vTaskDelayUntil( &xLastWakeTime, xPeriod);			
     5d2:	6a ef       	ldi	r22, 0xFA	; 250
     5d4:	70 e0       	ldi	r23, 0x00	; 0
     5d6:	ce 01       	movw	r24, r28
     5d8:	01 96       	adiw	r24, 0x01	; 1
     5da:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
			LedLow();
     5de:	0e 94 a2 02 	call	0x544	; 0x544 <LedLow>
			vTaskDelayUntil( &xLastWakeTime, xPeriod );
     5e2:	6a ef       	ldi	r22, 0xFA	; 250
     5e4:	70 e0       	ldi	r23, 0x00	; 0
     5e6:	ce 01       	movw	r24, r28
     5e8:	01 96       	adiw	r24, 0x01	; 1
     5ea:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
     5ee:	e1 cf       	rjmp	.-62     	; 0x5b2 <period_blinking+0x2c>
		}
	}
	xSemaphoreGive(xSemaphore);
     5f0:	20 e0       	ldi	r18, 0x00	; 0
     5f2:	40 e0       	ldi	r20, 0x00	; 0
     5f4:	50 e0       	ldi	r21, 0x00	; 0
     5f6:	60 e0       	ldi	r22, 0x00	; 0
     5f8:	70 e0       	ldi	r23, 0x00	; 0
     5fa:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     5fe:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     602:	0e 94 11 06 	call	0xc22	; 0xc22 <xQueueGenericSend>
	vTaskDelete(NULL);	
     606:	80 e0       	ldi	r24, 0x00	; 0
     608:	90 e0       	ldi	r25, 0x00	; 0
     60a:	0e 94 9c 08 	call	0x1138	; 0x1138 <vTaskDelete>

     60e:	0f 90       	pop	r0
     610:	0f 90       	pop	r0
     612:	df 91       	pop	r29
     614:	cf 91       	pop	r28
     616:	08 95       	ret

00000618 <KeyPad_AdjustKeyNumber>:
	return NULL;//Indicate No key pressed
}

unsigned char KeyPad_AdjustKeyNumber(unsigned char button_number)
{
	switch(button_number)
     618:	90 e0       	ldi	r25, 0x00	; 0
     61a:	fc 01       	movw	r30, r24
     61c:	31 97       	sbiw	r30, 0x01	; 1
     61e:	e0 31       	cpi	r30, 0x10	; 16
     620:	f1 05       	cpc	r31, r1
     622:	10 f5       	brcc	.+68     	; 0x668 <KeyPad_AdjustKeyNumber+0x50>
     624:	e6 5d       	subi	r30, 0xD6	; 214
     626:	ff 4f       	sbci	r31, 0xFF	; 255
     628:	0c 94 3a 0d 	jmp	0x1a74	; 0x1a74 <__tablejump2__>
	{
		case 1: return '7';
		break;
		case 2: return '8';
     62c:	88 e3       	ldi	r24, 0x38	; 56
     62e:	08 95       	ret
		break;
		case 3: return '9';
     630:	89 e3       	ldi	r24, 0x39	; 57
     632:	08 95       	ret
		break;
		case 4: return '0'; // ASCII Code of %
     634:	80 e3       	ldi	r24, 0x30	; 48
     636:	08 95       	ret
		break;
		case 5: return '4';
     638:	84 e3       	ldi	r24, 0x34	; 52
     63a:	08 95       	ret
		break;
		case 6: return '5';
     63c:	85 e3       	ldi	r24, 0x35	; 53
     63e:	08 95       	ret
		break;
		case 7: return '6';
     640:	86 e3       	ldi	r24, 0x36	; 54
     642:	08 95       	ret
		break;
		case 8: return '*'; /* ASCII Code of '*' */
     644:	8a e2       	ldi	r24, 0x2A	; 42
     646:	08 95       	ret
		break;
		case 9: return '1';
     648:	81 e3       	ldi	r24, 0x31	; 49
     64a:	08 95       	ret
		break;
		case 10: return '2';
     64c:	82 e3       	ldi	r24, 0x32	; 50
     64e:	08 95       	ret
		break;
		case 11: return '3';
     650:	83 e3       	ldi	r24, 0x33	; 51
     652:	08 95       	ret
		break;
		case 12: return '-'; /* ASCII Code of '-' */
     654:	8d e2       	ldi	r24, 0x2D	; 45
     656:	08 95       	ret
		break;
		case 13: return 13;  /* ASCII of Enter */
     658:	8d e0       	ldi	r24, 0x0D	; 13
     65a:	08 95       	ret
		break;
		case 14: return '0';
     65c:	80 e3       	ldi	r24, 0x30	; 48
     65e:	08 95       	ret
		break;
		case 15: return '='; /* ASCII Code of '=' */
     660:	8d e3       	ldi	r24, 0x3D	; 61
     662:	08 95       	ret
		break;
		case 16: return '+'; /* ASCII Code of '+' */
     664:	8b e2       	ldi	r24, 0x2B	; 43
     666:	08 95       	ret
		break;
		default: return NULL;
     668:	80 e0       	ldi	r24, 0x00	; 0
     66a:	08 95       	ret

unsigned char KeyPad_AdjustKeyNumber(unsigned char button_number)
{
	switch(button_number)
	{
		case 1: return '7';
     66c:	87 e3       	ldi	r24, 0x37	; 55
		case 16: return '+'; /* ASCII Code of '+' */
		break;
		default: return NULL;
	}

}
     66e:	08 95       	ret

00000670 <GetKeyPressed>:
		_delay_ms(25);
	}
}

uint8_t GetKeyPressed(void)
{
     670:	af 92       	push	r10
     672:	bf 92       	push	r11
     674:	cf 92       	push	r12
     676:	df 92       	push	r13
     678:	ef 92       	push	r14
     67a:	ff 92       	push	r15
     67c:	0f 93       	push	r16
     67e:	1f 93       	push	r17
     680:	cf 93       	push	r28
     682:	df 93       	push	r29
	 uint8_t r,c;
	KEYPAD_PORT|= 0X0F;
     684:	85 b3       	in	r24, 0x15	; 21
     686:	8f 60       	ori	r24, 0x0F	; 15
     688:	85 bb       	out	0x15, r24	; 21
     68a:	00 e0       	ldi	r16, 0x00	; 0
     68c:	10 e0       	ldi	r17, 0x00	; 0
	
	for(c=0;c<4;c++)
	{
		KEYPAD_DDR &=~(0X7F);
		KEYPAD_DDR |=(0X40>>c);
     68e:	68 94       	set
     690:	cc 24       	eor	r12, r12
     692:	c6 f8       	bld	r12, 6
     694:	d1 2c       	mov	r13, r1
		for(r=0;r<4;r++)
		{
			if(!(KEYPAD_PIN & (0X08>>r)))
     696:	68 94       	set
     698:	ee 24       	eor	r14, r14
     69a:	e3 f8       	bld	r14, 3
     69c:	f1 2c       	mov	r15, r1
     69e:	b0 2e       	mov	r11, r16
	 uint8_t r,c;
	KEYPAD_PORT|= 0X0F;
	
	for(c=0;c<4;c++)
	{
		KEYPAD_DDR &=~(0X7F);
     6a0:	84 b3       	in	r24, 0x14	; 20
     6a2:	80 78       	andi	r24, 0x80	; 128
     6a4:	84 bb       	out	0x14, r24	; 20
		KEYPAD_DDR |=(0X40>>c);
     6a6:	84 b3       	in	r24, 0x14	; 20
     6a8:	96 01       	movw	r18, r12
     6aa:	00 2e       	mov	r0, r16
     6ac:	02 c0       	rjmp	.+4      	; 0x6b2 <GetKeyPressed+0x42>
     6ae:	35 95       	asr	r19
     6b0:	27 95       	ror	r18
     6b2:	0a 94       	dec	r0
     6b4:	e2 f7       	brpl	.-8      	; 0x6ae <GetKeyPressed+0x3e>
     6b6:	28 2b       	or	r18, r24
     6b8:	24 bb       	out	0x14, r18	; 20
     6ba:	c0 e0       	ldi	r28, 0x00	; 0
     6bc:	d0 e0       	ldi	r29, 0x00	; 0
     6be:	ac 2e       	mov	r10, r28
		for(r=0;r<4;r++)
		{
			if(!(KEYPAD_PIN & (0X08>>r)))
     6c0:	23 b3       	in	r18, 0x13	; 19
     6c2:	30 e0       	ldi	r19, 0x00	; 0
     6c4:	a7 01       	movw	r20, r14
     6c6:	0c 2e       	mov	r0, r28
     6c8:	02 c0       	rjmp	.+4      	; 0x6ce <GetKeyPressed+0x5e>
     6ca:	55 95       	asr	r21
     6cc:	47 95       	ror	r20
     6ce:	0a 94       	dec	r0
     6d0:	e2 f7       	brpl	.-8      	; 0x6ca <GetKeyPressed+0x5a>
     6d2:	24 23       	and	r18, r20
     6d4:	35 23       	and	r19, r21
     6d6:	23 2b       	or	r18, r19
     6d8:	e9 f4       	brne	.+58     	; 0x714 <GetKeyPressed+0xa4>
			 {	
				if(xSemaphoreTake(xSemaphore,portMAX_DELAY)==pdTRUE)
     6da:	20 e0       	ldi	r18, 0x00	; 0
     6dc:	4f ef       	ldi	r20, 0xFF	; 255
     6de:	5f ef       	ldi	r21, 0xFF	; 255
     6e0:	60 e0       	ldi	r22, 0x00	; 0
     6e2:	70 e0       	ldi	r23, 0x00	; 0
     6e4:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     6e8:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     6ec:	0e 94 ab 06 	call	0xd56	; 0xd56 <xQueueGenericReceive>
     6f0:	81 30       	cpi	r24, 0x01	; 1
     6f2:	81 f4       	brne	.+32     	; 0x714 <GetKeyPressed+0xa4>
				{
					uint8_t x= KeyPad_AdjustKeyNumber((r*4)+c+1);
     6f4:	aa 0c       	add	r10, r10
     6f6:	aa 0c       	add	r10, r10
     6f8:	8b 0d       	add	r24, r11
     6fa:	8a 0d       	add	r24, r10
     6fc:	0e 94 0c 03 	call	0x618	; 0x618 <KeyPad_AdjustKeyNumber>
     700:	c8 2f       	mov	r28, r24
					lcd_disp_string_xy(x,0,0);
     702:	40 e0       	ldi	r20, 0x00	; 0
     704:	50 e0       	ldi	r21, 0x00	; 0
     706:	60 e0       	ldi	r22, 0x00	; 0
     708:	70 e0       	ldi	r23, 0x00	; 0
     70a:	90 e0       	ldi	r25, 0x00	; 0
     70c:	0e 94 ff 00 	call	0x1fe	; 0x1fe <lcd_disp_string_xy>
					return KeyPad_AdjustKeyNumber((r*4)+c+1);
     710:	8c 2f       	mov	r24, r28
     712:	0b c0       	rjmp	.+22     	; 0x72a <GetKeyPressed+0xba>
     714:	21 96       	adiw	r28, 0x01	; 1
	
	for(c=0;c<4;c++)
	{
		KEYPAD_DDR &=~(0X7F);
		KEYPAD_DDR |=(0X40>>c);
		for(r=0;r<4;r++)
     716:	c4 30       	cpi	r28, 0x04	; 4
     718:	d1 05       	cpc	r29, r1
     71a:	89 f6       	brne	.-94     	; 0x6be <GetKeyPressed+0x4e>
     71c:	0f 5f       	subi	r16, 0xFF	; 255
     71e:	1f 4f       	sbci	r17, 0xFF	; 255
uint8_t GetKeyPressed(void)
{
	 uint8_t r,c;
	KEYPAD_PORT|= 0X0F;
	
	for(c=0;c<4;c++)
     720:	04 30       	cpi	r16, 0x04	; 4
     722:	11 05       	cpc	r17, r1
     724:	09 f0       	breq	.+2      	; 0x728 <GetKeyPressed+0xb8>
     726:	bb cf       	rjmp	.-138    	; 0x69e <GetKeyPressed+0x2e>
				}		 				
			 }
		}
	}
	
	return NULL;//Indicate No key pressed
     728:	80 e0       	ldi	r24, 0x00	; 0
}
     72a:	df 91       	pop	r29
     72c:	cf 91       	pop	r28
     72e:	1f 91       	pop	r17
     730:	0f 91       	pop	r16
     732:	ff 90       	pop	r15
     734:	ef 90       	pop	r14
     736:	df 90       	pop	r13
     738:	cf 90       	pop	r12
     73a:	bf 90       	pop	r11
     73c:	af 90       	pop	r10
     73e:	08 95       	ret

00000740 <period_lcd_press>:
	xSemaphoreGive(xSemaphore);
	vTaskDelete(NULL);
}

void period_lcd_press(void *p)
{
     740:	cf 93       	push	r28
     742:	df 93       	push	r29
     744:	00 d0       	rcall	.+0      	; 0x746 <period_lcd_press+0x6>
     746:	cd b7       	in	r28, 0x3d	; 61
     748:	de b7       	in	r29, 0x3e	; 62
	portTickType xLastWakeTime;
	const portTickType xPeriod_on  = 500;
	const portTickType xPeriod_off = 250;
	const portTickType time = portMAX_DELAY;	
	xLastWakeTime = xTaskGetTickCount();
     74a:	0e 94 16 09 	call	0x122c	; 0x122c <xTaskGetTickCount>
     74e:	9a 83       	std	Y+2, r25	; 0x02
     750:	89 83       	std	Y+1, r24	; 0x01
	if(xSemaphoreTake(xSemaphore,time)==pdTRUE)
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	4f ef       	ldi	r20, 0xFF	; 255
     756:	5f ef       	ldi	r21, 0xFF	; 255
     758:	60 e0       	ldi	r22, 0x00	; 0
     75a:	70 e0       	ldi	r23, 0x00	; 0
     75c:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     760:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     764:	0e 94 ab 06 	call	0xd56	; 0xd56 <xQueueGenericReceive>
     768:	81 30       	cpi	r24, 0x01	; 1
     76a:	91 f5       	brne	.+100    	; 0x7d0 <period_lcd_press+0x90>
	{
		while((xLastWakeTime<=10000))
     76c:	89 81       	ldd	r24, Y+1	; 0x01
     76e:	9a 81       	ldd	r25, Y+2	; 0x02
     770:	81 31       	cpi	r24, 0x11	; 17
     772:	97 42       	sbci	r25, 0x27	; 39
     774:	68 f5       	brcc	.+90     	; 0x7d0 <period_lcd_press+0x90>
		{				
			LcdWrite_blink();
     776:	0e 94 8f 02 	call	0x51e	; 0x51e <LcdWrite_blink>
			vTaskDelayUntil( &xLastWakeTime, xPeriod_on );
     77a:	64 ef       	ldi	r22, 0xF4	; 244
     77c:	71 e0       	ldi	r23, 0x01	; 1
     77e:	ce 01       	movw	r24, r28
     780:	01 96       	adiw	r24, 0x01	; 1
     782:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
			lcd_clrScreen();
     786:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <lcd_clrScreen>
			vTaskDelayUntil( &xLastWakeTime, xPeriod_off );
     78a:	6a ef       	ldi	r22, 0xFA	; 250
     78c:	70 e0       	ldi	r23, 0x00	; 0
     78e:	ce 01       	movw	r24, r28
     790:	01 96       	adiw	r24, 0x01	; 1
     792:	0e 94 69 0a 	call	0x14d2	; 0x14d2 <vTaskDelayUntil>
			xSemaphoreGive(xSemaphore);
     796:	20 e0       	ldi	r18, 0x00	; 0
     798:	40 e0       	ldi	r20, 0x00	; 0
     79a:	50 e0       	ldi	r21, 0x00	; 0
     79c:	60 e0       	ldi	r22, 0x00	; 0
     79e:	70 e0       	ldi	r23, 0x00	; 0
     7a0:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     7a4:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     7a8:	0e 94 11 06 	call	0xc22	; 0xc22 <xQueueGenericSend>
			GetKeyPressed();
     7ac:	0e 94 38 03 	call	0x670	; 0x670 <GetKeyPressed>
			xSemaphoreTake(xSemaphore,time);
     7b0:	20 e0       	ldi	r18, 0x00	; 0
     7b2:	4f ef       	ldi	r20, 0xFF	; 255
     7b4:	5f ef       	ldi	r21, 0xFF	; 255
     7b6:	60 e0       	ldi	r22, 0x00	; 0
     7b8:	70 e0       	ldi	r23, 0x00	; 0
     7ba:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     7be:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     7c2:	0e 94 ab 06 	call	0xd56	; 0xd56 <xQueueGenericReceive>
	const portTickType xPeriod_off = 250;
	const portTickType time = portMAX_DELAY;	
	xLastWakeTime = xTaskGetTickCount();
	if(xSemaphoreTake(xSemaphore,time)==pdTRUE)
	{
		while((xLastWakeTime<=10000))
     7c6:	89 81       	ldd	r24, Y+1	; 0x01
     7c8:	9a 81       	ldd	r25, Y+2	; 0x02
     7ca:	81 31       	cpi	r24, 0x11	; 17
     7cc:	97 42       	sbci	r25, 0x27	; 39
     7ce:	98 f2       	brcs	.-90     	; 0x776 <period_lcd_press+0x36>
			GetKeyPressed();
			xSemaphoreTake(xSemaphore,time);
			
		}
	}
	lcd_clrScreen();
     7d0:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <lcd_clrScreen>
	xSemaphoreGive(xSemaphore);
     7d4:	20 e0       	ldi	r18, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	60 e0       	ldi	r22, 0x00	; 0
     7dc:	70 e0       	ldi	r23, 0x00	; 0
     7de:	80 91 56 03 	lds	r24, 0x0356	; 0x800356 <xSemaphore>
     7e2:	90 91 57 03 	lds	r25, 0x0357	; 0x800357 <xSemaphore+0x1>
     7e6:	0e 94 11 06 	call	0xc22	; 0xc22 <xQueueGenericSend>
	vTaskDelete(NULL);
     7ea:	80 e0       	ldi	r24, 0x00	; 0
     7ec:	90 e0       	ldi	r25, 0x00	; 0
     7ee:	0e 94 9c 08 	call	0x1138	; 0x1138 <vTaskDelete>
}
     7f2:	0f 90       	pop	r0
     7f4:	0f 90       	pop	r0
     7f6:	df 91       	pop	r29
     7f8:	cf 91       	pop	r28
     7fa:	08 95       	ret

000007fc <pxPortInitialiseStack>:
	portSAVE_CONTEXT();
	vTaskIncrementTick();
	vTaskSwitchContext();
	portRESTORE_CONTEXT();

	asm volatile ( "ret" );
     7fc:	31 e1       	ldi	r19, 0x11	; 17
     7fe:	fc 01       	movw	r30, r24
     800:	30 83       	st	Z, r19
     802:	31 97       	sbiw	r30, 0x01	; 1
     804:	22 e2       	ldi	r18, 0x22	; 34
     806:	20 83       	st	Z, r18
     808:	31 97       	sbiw	r30, 0x01	; 1
     80a:	a3 e3       	ldi	r26, 0x33	; 51
     80c:	a0 83       	st	Z, r26
     80e:	31 97       	sbiw	r30, 0x01	; 1
     810:	60 83       	st	Z, r22
     812:	31 97       	sbiw	r30, 0x01	; 1
     814:	70 83       	st	Z, r23
     816:	31 97       	sbiw	r30, 0x01	; 1
     818:	10 82       	st	Z, r1
     81a:	31 97       	sbiw	r30, 0x01	; 1
     81c:	60 e8       	ldi	r22, 0x80	; 128
     81e:	60 83       	st	Z, r22
     820:	31 97       	sbiw	r30, 0x01	; 1
     822:	10 82       	st	Z, r1
     824:	31 97       	sbiw	r30, 0x01	; 1
     826:	62 e0       	ldi	r22, 0x02	; 2
     828:	60 83       	st	Z, r22
     82a:	31 97       	sbiw	r30, 0x01	; 1
     82c:	63 e0       	ldi	r22, 0x03	; 3
     82e:	60 83       	st	Z, r22
     830:	31 97       	sbiw	r30, 0x01	; 1
     832:	64 e0       	ldi	r22, 0x04	; 4
     834:	60 83       	st	Z, r22
     836:	31 97       	sbiw	r30, 0x01	; 1
     838:	65 e0       	ldi	r22, 0x05	; 5
     83a:	60 83       	st	Z, r22
     83c:	31 97       	sbiw	r30, 0x01	; 1
     83e:	66 e0       	ldi	r22, 0x06	; 6
     840:	60 83       	st	Z, r22
     842:	31 97       	sbiw	r30, 0x01	; 1
     844:	67 e0       	ldi	r22, 0x07	; 7
     846:	60 83       	st	Z, r22
     848:	31 97       	sbiw	r30, 0x01	; 1
     84a:	68 e0       	ldi	r22, 0x08	; 8
     84c:	60 83       	st	Z, r22
     84e:	31 97       	sbiw	r30, 0x01	; 1
     850:	69 e0       	ldi	r22, 0x09	; 9
     852:	60 83       	st	Z, r22
     854:	31 97       	sbiw	r30, 0x01	; 1
     856:	60 e1       	ldi	r22, 0x10	; 16
     858:	60 83       	st	Z, r22
     85a:	31 97       	sbiw	r30, 0x01	; 1
     85c:	30 83       	st	Z, r19
     85e:	31 97       	sbiw	r30, 0x01	; 1
     860:	32 e1       	ldi	r19, 0x12	; 18
     862:	30 83       	st	Z, r19
     864:	31 97       	sbiw	r30, 0x01	; 1
     866:	33 e1       	ldi	r19, 0x13	; 19
     868:	30 83       	st	Z, r19
     86a:	31 97       	sbiw	r30, 0x01	; 1
     86c:	34 e1       	ldi	r19, 0x14	; 20
     86e:	30 83       	st	Z, r19
     870:	31 97       	sbiw	r30, 0x01	; 1
     872:	35 e1       	ldi	r19, 0x15	; 21
     874:	30 83       	st	Z, r19
     876:	31 97       	sbiw	r30, 0x01	; 1
     878:	36 e1       	ldi	r19, 0x16	; 22
     87a:	30 83       	st	Z, r19
     87c:	31 97       	sbiw	r30, 0x01	; 1
     87e:	37 e1       	ldi	r19, 0x17	; 23
     880:	30 83       	st	Z, r19
     882:	31 97       	sbiw	r30, 0x01	; 1
     884:	38 e1       	ldi	r19, 0x18	; 24
     886:	30 83       	st	Z, r19
     888:	31 97       	sbiw	r30, 0x01	; 1
     88a:	39 e1       	ldi	r19, 0x19	; 25
     88c:	30 83       	st	Z, r19
     88e:	31 97       	sbiw	r30, 0x01	; 1
     890:	30 e2       	ldi	r19, 0x20	; 32
     892:	30 83       	st	Z, r19
     894:	31 97       	sbiw	r30, 0x01	; 1
     896:	31 e2       	ldi	r19, 0x21	; 33
     898:	30 83       	st	Z, r19
     89a:	31 97       	sbiw	r30, 0x01	; 1
     89c:	20 83       	st	Z, r18
     89e:	31 97       	sbiw	r30, 0x01	; 1
     8a0:	23 e2       	ldi	r18, 0x23	; 35
     8a2:	20 83       	st	Z, r18
     8a4:	31 97       	sbiw	r30, 0x01	; 1
     8a6:	40 83       	st	Z, r20
     8a8:	31 97       	sbiw	r30, 0x01	; 1
     8aa:	50 83       	st	Z, r21
     8ac:	31 97       	sbiw	r30, 0x01	; 1
     8ae:	26 e2       	ldi	r18, 0x26	; 38
     8b0:	20 83       	st	Z, r18
     8b2:	31 97       	sbiw	r30, 0x01	; 1
     8b4:	27 e2       	ldi	r18, 0x27	; 39
     8b6:	20 83       	st	Z, r18
     8b8:	31 97       	sbiw	r30, 0x01	; 1
     8ba:	28 e2       	ldi	r18, 0x28	; 40
     8bc:	20 83       	st	Z, r18
     8be:	31 97       	sbiw	r30, 0x01	; 1
     8c0:	29 e2       	ldi	r18, 0x29	; 41
     8c2:	20 83       	st	Z, r18
     8c4:	31 97       	sbiw	r30, 0x01	; 1
     8c6:	20 e3       	ldi	r18, 0x30	; 48
     8c8:	20 83       	st	Z, r18
     8ca:	31 97       	sbiw	r30, 0x01	; 1
     8cc:	21 e3       	ldi	r18, 0x31	; 49
     8ce:	20 83       	st	Z, r18
     8d0:	86 97       	sbiw	r24, 0x26	; 38
     8d2:	08 95       	ret

000008d4 <xPortStartScheduler>:
     8d4:	1b bc       	out	0x2b, r1	; 43
     8d6:	8c e7       	ldi	r24, 0x7C	; 124
     8d8:	8a bd       	out	0x2a, r24	; 42
     8da:	8b e0       	ldi	r24, 0x0B	; 11
     8dc:	8e bd       	out	0x2e, r24	; 46
     8de:	89 b7       	in	r24, 0x39	; 57
     8e0:	80 61       	ori	r24, 0x10	; 16
     8e2:	89 bf       	out	0x39, r24	; 57
     8e4:	a0 91 52 03 	lds	r26, 0x0352	; 0x800352 <pxCurrentTCB>
     8e8:	b0 91 53 03 	lds	r27, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
     8ec:	cd 91       	ld	r28, X+
     8ee:	cd bf       	out	0x3d, r28	; 61
     8f0:	dd 91       	ld	r29, X+
     8f2:	de bf       	out	0x3e, r29	; 62
     8f4:	ff 91       	pop	r31
     8f6:	ef 91       	pop	r30
     8f8:	df 91       	pop	r29
     8fa:	cf 91       	pop	r28
     8fc:	bf 91       	pop	r27
     8fe:	af 91       	pop	r26
     900:	9f 91       	pop	r25
     902:	8f 91       	pop	r24
     904:	7f 91       	pop	r23
     906:	6f 91       	pop	r22
     908:	5f 91       	pop	r21
     90a:	4f 91       	pop	r20
     90c:	3f 91       	pop	r19
     90e:	2f 91       	pop	r18
     910:	1f 91       	pop	r17
     912:	0f 91       	pop	r16
     914:	ff 90       	pop	r15
     916:	ef 90       	pop	r14
     918:	df 90       	pop	r13
     91a:	cf 90       	pop	r12
     91c:	bf 90       	pop	r11
     91e:	af 90       	pop	r10
     920:	9f 90       	pop	r9
     922:	8f 90       	pop	r8
     924:	7f 90       	pop	r7
     926:	6f 90       	pop	r6
     928:	5f 90       	pop	r5
     92a:	4f 90       	pop	r4
     92c:	3f 90       	pop	r3
     92e:	2f 90       	pop	r2
     930:	1f 90       	pop	r1
     932:	0f 90       	pop	r0
     934:	0f be       	out	0x3f, r0	; 63
     936:	0f 90       	pop	r0
     938:	08 95       	ret
     93a:	81 e0       	ldi	r24, 0x01	; 1
     93c:	08 95       	ret

0000093e <vPortYield>:
     93e:	0f 92       	push	r0
     940:	0f b6       	in	r0, 0x3f	; 63
     942:	f8 94       	cli
     944:	0f 92       	push	r0
     946:	1f 92       	push	r1
     948:	11 24       	eor	r1, r1
     94a:	2f 92       	push	r2
     94c:	3f 92       	push	r3
     94e:	4f 92       	push	r4
     950:	5f 92       	push	r5
     952:	6f 92       	push	r6
     954:	7f 92       	push	r7
     956:	8f 92       	push	r8
     958:	9f 92       	push	r9
     95a:	af 92       	push	r10
     95c:	bf 92       	push	r11
     95e:	cf 92       	push	r12
     960:	df 92       	push	r13
     962:	ef 92       	push	r14
     964:	ff 92       	push	r15
     966:	0f 93       	push	r16
     968:	1f 93       	push	r17
     96a:	2f 93       	push	r18
     96c:	3f 93       	push	r19
     96e:	4f 93       	push	r20
     970:	5f 93       	push	r21
     972:	6f 93       	push	r22
     974:	7f 93       	push	r23
     976:	8f 93       	push	r24
     978:	9f 93       	push	r25
     97a:	af 93       	push	r26
     97c:	bf 93       	push	r27
     97e:	cf 93       	push	r28
     980:	df 93       	push	r29
     982:	ef 93       	push	r30
     984:	ff 93       	push	r31
     986:	a0 91 52 03 	lds	r26, 0x0352	; 0x800352 <pxCurrentTCB>
     98a:	b0 91 53 03 	lds	r27, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
     98e:	0d b6       	in	r0, 0x3d	; 61
     990:	0d 92       	st	X+, r0
     992:	0e b6       	in	r0, 0x3e	; 62
     994:	0d 92       	st	X+, r0
     996:	0e 94 e5 0a 	call	0x15ca	; 0x15ca <vTaskSwitchContext>
     99a:	a0 91 52 03 	lds	r26, 0x0352	; 0x800352 <pxCurrentTCB>
     99e:	b0 91 53 03 	lds	r27, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
     9a2:	cd 91       	ld	r28, X+
     9a4:	cd bf       	out	0x3d, r28	; 61
     9a6:	dd 91       	ld	r29, X+
     9a8:	de bf       	out	0x3e, r29	; 62
     9aa:	ff 91       	pop	r31
     9ac:	ef 91       	pop	r30
     9ae:	df 91       	pop	r29
     9b0:	cf 91       	pop	r28
     9b2:	bf 91       	pop	r27
     9b4:	af 91       	pop	r26
     9b6:	9f 91       	pop	r25
     9b8:	8f 91       	pop	r24
     9ba:	7f 91       	pop	r23
     9bc:	6f 91       	pop	r22
     9be:	5f 91       	pop	r21
     9c0:	4f 91       	pop	r20
     9c2:	3f 91       	pop	r19
     9c4:	2f 91       	pop	r18
     9c6:	1f 91       	pop	r17
     9c8:	0f 91       	pop	r16
     9ca:	ff 90       	pop	r15
     9cc:	ef 90       	pop	r14
     9ce:	df 90       	pop	r13
     9d0:	cf 90       	pop	r12
     9d2:	bf 90       	pop	r11
     9d4:	af 90       	pop	r10
     9d6:	9f 90       	pop	r9
     9d8:	8f 90       	pop	r8
     9da:	7f 90       	pop	r7
     9dc:	6f 90       	pop	r6
     9de:	5f 90       	pop	r5
     9e0:	4f 90       	pop	r4
     9e2:	3f 90       	pop	r3
     9e4:	2f 90       	pop	r2
     9e6:	1f 90       	pop	r1
     9e8:	0f 90       	pop	r0
     9ea:	0f be       	out	0x3f, r0	; 63
     9ec:	0f 90       	pop	r0
     9ee:	08 95       	ret

000009f0 <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal ) );
	void TIMER1_COMPA_vect( void )
	{
     9f0:	1f 92       	push	r1
     9f2:	0f 92       	push	r0
     9f4:	0f b6       	in	r0, 0x3f	; 63
     9f6:	0f 92       	push	r0
     9f8:	11 24       	eor	r1, r1
     9fa:	2f 93       	push	r18
     9fc:	3f 93       	push	r19
     9fe:	4f 93       	push	r20
     a00:	5f 93       	push	r21
     a02:	6f 93       	push	r22
     a04:	7f 93       	push	r23
     a06:	8f 93       	push	r24
     a08:	9f 93       	push	r25
     a0a:	af 93       	push	r26
     a0c:	bf 93       	push	r27
     a0e:	ef 93       	push	r30
     a10:	ff 93       	push	r31
		vTaskIncrementTick();
     a12:	0e 94 20 09 	call	0x1240	; 0x1240 <vTaskIncrementTick>
	}
     a16:	ff 91       	pop	r31
     a18:	ef 91       	pop	r30
     a1a:	bf 91       	pop	r27
     a1c:	af 91       	pop	r26
     a1e:	9f 91       	pop	r25
     a20:	8f 91       	pop	r24
     a22:	7f 91       	pop	r23
     a24:	6f 91       	pop	r22
     a26:	5f 91       	pop	r21
     a28:	4f 91       	pop	r20
     a2a:	3f 91       	pop	r19
     a2c:	2f 91       	pop	r18
     a2e:	0f 90       	pop	r0
     a30:	0f be       	out	0x3f, r0	; 63
     a32:	0f 90       	pop	r0
     a34:	1f 90       	pop	r1
     a36:	18 95       	reti

00000a38 <prvCopyDataToQueue>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
     a3c:	ec 01       	movw	r28, r24
     a3e:	8c 8d       	ldd	r24, Y+28	; 0x1c
     a40:	88 23       	and	r24, r24
     a42:	a9 f1       	breq	.+106    	; 0xaae <prvCopyDataToQueue+0x76>
     a44:	41 11       	cpse	r20, r1
     a46:	17 c0       	rjmp	.+46     	; 0xa76 <prvCopyDataToQueue+0x3e>
     a48:	48 2f       	mov	r20, r24
     a4a:	50 e0       	ldi	r21, 0x00	; 0
     a4c:	8c 81       	ldd	r24, Y+4	; 0x04
     a4e:	9d 81       	ldd	r25, Y+5	; 0x05
     a50:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <memcpy>
     a54:	2c 8d       	ldd	r18, Y+28	; 0x1c
     a56:	8c 81       	ldd	r24, Y+4	; 0x04
     a58:	9d 81       	ldd	r25, Y+5	; 0x05
     a5a:	82 0f       	add	r24, r18
     a5c:	91 1d       	adc	r25, r1
     a5e:	9d 83       	std	Y+5, r25	; 0x05
     a60:	8c 83       	std	Y+4, r24	; 0x04
     a62:	2a 81       	ldd	r18, Y+2	; 0x02
     a64:	3b 81       	ldd	r19, Y+3	; 0x03
     a66:	82 17       	cp	r24, r18
     a68:	93 07       	cpc	r25, r19
     a6a:	08 f1       	brcs	.+66     	; 0xaae <prvCopyDataToQueue+0x76>
     a6c:	88 81       	ld	r24, Y
     a6e:	99 81       	ldd	r25, Y+1	; 0x01
     a70:	9d 83       	std	Y+5, r25	; 0x05
     a72:	8c 83       	std	Y+4, r24	; 0x04
     a74:	1c c0       	rjmp	.+56     	; 0xaae <prvCopyDataToQueue+0x76>
     a76:	48 2f       	mov	r20, r24
     a78:	50 e0       	ldi	r21, 0x00	; 0
     a7a:	8e 81       	ldd	r24, Y+6	; 0x06
     a7c:	9f 81       	ldd	r25, Y+7	; 0x07
     a7e:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <memcpy>
     a82:	8c 8d       	ldd	r24, Y+28	; 0x1c
     a84:	90 e0       	ldi	r25, 0x00	; 0
     a86:	91 95       	neg	r25
     a88:	81 95       	neg	r24
     a8a:	91 09       	sbc	r25, r1
     a8c:	2e 81       	ldd	r18, Y+6	; 0x06
     a8e:	3f 81       	ldd	r19, Y+7	; 0x07
     a90:	28 0f       	add	r18, r24
     a92:	39 1f       	adc	r19, r25
     a94:	3f 83       	std	Y+7, r19	; 0x07
     a96:	2e 83       	std	Y+6, r18	; 0x06
     a98:	48 81       	ld	r20, Y
     a9a:	59 81       	ldd	r21, Y+1	; 0x01
     a9c:	24 17       	cp	r18, r20
     a9e:	35 07       	cpc	r19, r21
     aa0:	30 f4       	brcc	.+12     	; 0xaae <prvCopyDataToQueue+0x76>
     aa2:	2a 81       	ldd	r18, Y+2	; 0x02
     aa4:	3b 81       	ldd	r19, Y+3	; 0x03
     aa6:	82 0f       	add	r24, r18
     aa8:	93 1f       	adc	r25, r19
     aaa:	9f 83       	std	Y+7, r25	; 0x07
     aac:	8e 83       	std	Y+6, r24	; 0x06
     aae:	8a 8d       	ldd	r24, Y+26	; 0x1a
     ab0:	8f 5f       	subi	r24, 0xFF	; 255
     ab2:	8a 8f       	std	Y+26, r24	; 0x1a
     ab4:	df 91       	pop	r29
     ab6:	cf 91       	pop	r28
     ab8:	08 95       	ret

00000aba <prvCopyDataFromQueue>:
     aba:	fc 01       	movw	r30, r24
     abc:	80 81       	ld	r24, Z
     abe:	91 81       	ldd	r25, Z+1	; 0x01
     ac0:	00 97       	sbiw	r24, 0x00	; 0
     ac2:	a1 f0       	breq	.+40     	; 0xaec <prvCopyDataFromQueue+0x32>
     ac4:	44 8d       	ldd	r20, Z+28	; 0x1c
     ac6:	50 e0       	ldi	r21, 0x00	; 0
     ac8:	26 81       	ldd	r18, Z+6	; 0x06
     aca:	37 81       	ldd	r19, Z+7	; 0x07
     acc:	24 0f       	add	r18, r20
     ace:	35 1f       	adc	r19, r21
     ad0:	37 83       	std	Z+7, r19	; 0x07
     ad2:	26 83       	std	Z+6, r18	; 0x06
     ad4:	a2 81       	ldd	r26, Z+2	; 0x02
     ad6:	b3 81       	ldd	r27, Z+3	; 0x03
     ad8:	2a 17       	cp	r18, r26
     ada:	3b 07       	cpc	r19, r27
     adc:	10 f0       	brcs	.+4      	; 0xae2 <prvCopyDataFromQueue+0x28>
     ade:	97 83       	std	Z+7, r25	; 0x07
     ae0:	86 83       	std	Z+6, r24	; 0x06
     ae2:	cb 01       	movw	r24, r22
     ae4:	66 81       	ldd	r22, Z+6	; 0x06
     ae6:	77 81       	ldd	r23, Z+7	; 0x07
     ae8:	0e 94 40 0d 	call	0x1a80	; 0x1a80 <memcpy>
     aec:	08 95       	ret

00000aee <prvUnlockQueue>:
     aee:	0f 93       	push	r16
     af0:	1f 93       	push	r17
     af2:	cf 93       	push	r28
     af4:	df 93       	push	r29
     af6:	ec 01       	movw	r28, r24
     af8:	0f b6       	in	r0, 0x3f	; 63
     afa:	f8 94       	cli
     afc:	0f 92       	push	r0
     afe:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b00:	18 16       	cp	r1, r24
     b02:	b4 f4       	brge	.+44     	; 0xb30 <prvUnlockQueue+0x42>
     b04:	89 89       	ldd	r24, Y+17	; 0x11
     b06:	81 11       	cpse	r24, r1
     b08:	05 c0       	rjmp	.+10     	; 0xb14 <prvUnlockQueue+0x26>
     b0a:	12 c0       	rjmp	.+36     	; 0xb30 <prvUnlockQueue+0x42>
     b0c:	89 89       	ldd	r24, Y+17	; 0x11
     b0e:	81 11       	cpse	r24, r1
     b10:	04 c0       	rjmp	.+8      	; 0xb1a <prvUnlockQueue+0x2c>
     b12:	0e c0       	rjmp	.+28     	; 0xb30 <prvUnlockQueue+0x42>
     b14:	8e 01       	movw	r16, r28
     b16:	0f 5e       	subi	r16, 0xEF	; 239
     b18:	1f 4f       	sbci	r17, 0xFF	; 255
     b1a:	c8 01       	movw	r24, r16
     b1c:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskRemoveFromEventList>
     b20:	81 11       	cpse	r24, r1
     b22:	0e 94 0c 0c 	call	0x1818	; 0x1818 <vTaskMissedYield>
     b26:	8e 8d       	ldd	r24, Y+30	; 0x1e
     b28:	81 50       	subi	r24, 0x01	; 1
     b2a:	8e 8f       	std	Y+30, r24	; 0x1e
     b2c:	18 16       	cp	r1, r24
     b2e:	74 f3       	brlt	.-36     	; 0xb0c <prvUnlockQueue+0x1e>
     b30:	8f ef       	ldi	r24, 0xFF	; 255
     b32:	8e 8f       	std	Y+30, r24	; 0x1e
     b34:	0f 90       	pop	r0
     b36:	0f be       	out	0x3f, r0	; 63
     b38:	0f b6       	in	r0, 0x3f	; 63
     b3a:	f8 94       	cli
     b3c:	0f 92       	push	r0
     b3e:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b40:	18 16       	cp	r1, r24
     b42:	b4 f4       	brge	.+44     	; 0xb70 <prvUnlockQueue+0x82>
     b44:	88 85       	ldd	r24, Y+8	; 0x08
     b46:	81 11       	cpse	r24, r1
     b48:	05 c0       	rjmp	.+10     	; 0xb54 <prvUnlockQueue+0x66>
     b4a:	12 c0       	rjmp	.+36     	; 0xb70 <prvUnlockQueue+0x82>
     b4c:	88 85       	ldd	r24, Y+8	; 0x08
     b4e:	81 11       	cpse	r24, r1
     b50:	04 c0       	rjmp	.+8      	; 0xb5a <prvUnlockQueue+0x6c>
     b52:	0e c0       	rjmp	.+28     	; 0xb70 <prvUnlockQueue+0x82>
     b54:	8e 01       	movw	r16, r28
     b56:	08 5f       	subi	r16, 0xF8	; 248
     b58:	1f 4f       	sbci	r17, 0xFF	; 255
     b5a:	c8 01       	movw	r24, r16
     b5c:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskRemoveFromEventList>
     b60:	81 11       	cpse	r24, r1
     b62:	0e 94 0c 0c 	call	0x1818	; 0x1818 <vTaskMissedYield>
     b66:	8d 8d       	ldd	r24, Y+29	; 0x1d
     b68:	81 50       	subi	r24, 0x01	; 1
     b6a:	8d 8f       	std	Y+29, r24	; 0x1d
     b6c:	18 16       	cp	r1, r24
     b6e:	74 f3       	brlt	.-36     	; 0xb4c <prvUnlockQueue+0x5e>
     b70:	8f ef       	ldi	r24, 0xFF	; 255
     b72:	8d 8f       	std	Y+29, r24	; 0x1d
     b74:	0f 90       	pop	r0
     b76:	0f be       	out	0x3f, r0	; 63
     b78:	df 91       	pop	r29
     b7a:	cf 91       	pop	r28
     b7c:	1f 91       	pop	r17
     b7e:	0f 91       	pop	r16
     b80:	08 95       	ret

00000b82 <xQueueCreate>:
     b82:	cf 92       	push	r12
     b84:	df 92       	push	r13
     b86:	ef 92       	push	r14
     b88:	ff 92       	push	r15
     b8a:	0f 93       	push	r16
     b8c:	1f 93       	push	r17
     b8e:	cf 93       	push	r28
     b90:	df 93       	push	r29
     b92:	88 23       	and	r24, r24
     b94:	d1 f1       	breq	.+116    	; 0xc0a <xQueueCreate+0x88>
     b96:	e6 2e       	mov	r14, r22
     b98:	f8 2e       	mov	r15, r24
     b9a:	8f e1       	ldi	r24, 0x1F	; 31
     b9c:	90 e0       	ldi	r25, 0x00	; 0
     b9e:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
     ba2:	ec 01       	movw	r28, r24
     ba4:	89 2b       	or	r24, r25
     ba6:	99 f1       	breq	.+102    	; 0xc0e <xQueueCreate+0x8c>
     ba8:	ce 2c       	mov	r12, r14
     baa:	d1 2c       	mov	r13, r1
     bac:	fc 9c       	mul	r15, r12
     bae:	80 01       	movw	r16, r0
     bb0:	fd 9c       	mul	r15, r13
     bb2:	10 0d       	add	r17, r0
     bb4:	11 24       	eor	r1, r1
     bb6:	c8 01       	movw	r24, r16
     bb8:	01 96       	adiw	r24, 0x01	; 1
     bba:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
     bbe:	99 83       	std	Y+1, r25	; 0x01
     bc0:	88 83       	st	Y, r24
     bc2:	00 97       	sbiw	r24, 0x00	; 0
     bc4:	e1 f0       	breq	.+56     	; 0xbfe <xQueueCreate+0x7c>
     bc6:	9c 01       	movw	r18, r24
     bc8:	20 0f       	add	r18, r16
     bca:	31 1f       	adc	r19, r17
     bcc:	3b 83       	std	Y+3, r19	; 0x03
     bce:	2a 83       	std	Y+2, r18	; 0x02
     bd0:	1a 8e       	std	Y+26, r1	; 0x1a
     bd2:	9d 83       	std	Y+5, r25	; 0x05
     bd4:	8c 83       	std	Y+4, r24	; 0x04
     bd6:	0c 19       	sub	r16, r12
     bd8:	1d 09       	sbc	r17, r13
     bda:	08 0f       	add	r16, r24
     bdc:	19 1f       	adc	r17, r25
     bde:	1f 83       	std	Y+7, r17	; 0x07
     be0:	0e 83       	std	Y+6, r16	; 0x06
     be2:	fb 8e       	std	Y+27, r15	; 0x1b
     be4:	ec 8e       	std	Y+28, r14	; 0x1c
     be6:	8f ef       	ldi	r24, 0xFF	; 255
     be8:	8d 8f       	std	Y+29, r24	; 0x1d
     bea:	8e 8f       	std	Y+30, r24	; 0x1e
     bec:	ce 01       	movw	r24, r28
     bee:	08 96       	adiw	r24, 0x08	; 8
     bf0:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
     bf4:	ce 01       	movw	r24, r28
     bf6:	41 96       	adiw	r24, 0x11	; 17
     bf8:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
     bfc:	08 c0       	rjmp	.+16     	; 0xc0e <xQueueCreate+0x8c>
     bfe:	ce 01       	movw	r24, r28
     c00:	0e 94 7f 00 	call	0xfe	; 0xfe <vPortFree>
     c04:	c0 e0       	ldi	r28, 0x00	; 0
     c06:	d0 e0       	ldi	r29, 0x00	; 0
     c08:	02 c0       	rjmp	.+4      	; 0xc0e <xQueueCreate+0x8c>
     c0a:	c0 e0       	ldi	r28, 0x00	; 0
     c0c:	d0 e0       	ldi	r29, 0x00	; 0
     c0e:	ce 01       	movw	r24, r28
     c10:	df 91       	pop	r29
     c12:	cf 91       	pop	r28
     c14:	1f 91       	pop	r17
     c16:	0f 91       	pop	r16
     c18:	ff 90       	pop	r15
     c1a:	ef 90       	pop	r14
     c1c:	df 90       	pop	r13
     c1e:	cf 90       	pop	r12
     c20:	08 95       	ret

00000c22 <xQueueGenericSend>:
     c22:	9f 92       	push	r9
     c24:	af 92       	push	r10
     c26:	bf 92       	push	r11
     c28:	cf 92       	push	r12
     c2a:	df 92       	push	r13
     c2c:	ef 92       	push	r14
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17
     c34:	cf 93       	push	r28
     c36:	df 93       	push	r29
     c38:	00 d0       	rcall	.+0      	; 0xc3a <xQueueGenericSend+0x18>
     c3a:	00 d0       	rcall	.+0      	; 0xc3c <xQueueGenericSend+0x1a>
     c3c:	1f 92       	push	r1
     c3e:	cd b7       	in	r28, 0x3d	; 61
     c40:	de b7       	in	r29, 0x3e	; 62
     c42:	8c 01       	movw	r16, r24
     c44:	6b 01       	movw	r12, r22
     c46:	5d 83       	std	Y+5, r21	; 0x05
     c48:	4c 83       	std	Y+4, r20	; 0x04
     c4a:	92 2e       	mov	r9, r18
     c4c:	b1 2c       	mov	r11, r1
     c4e:	aa 24       	eor	r10, r10
     c50:	a3 94       	inc	r10
     c52:	7c 01       	movw	r14, r24
     c54:	88 e0       	ldi	r24, 0x08	; 8
     c56:	e8 0e       	add	r14, r24
     c58:	f1 1c       	adc	r15, r1
     c5a:	0f b6       	in	r0, 0x3f	; 63
     c5c:	f8 94       	cli
     c5e:	0f 92       	push	r0
     c60:	f8 01       	movw	r30, r16
     c62:	92 8d       	ldd	r25, Z+26	; 0x1a
     c64:	83 8d       	ldd	r24, Z+27	; 0x1b
     c66:	98 17       	cp	r25, r24
     c68:	a8 f4       	brcc	.+42     	; 0xc94 <xQueueGenericSend+0x72>
     c6a:	49 2d       	mov	r20, r9
     c6c:	b6 01       	movw	r22, r12
     c6e:	c8 01       	movw	r24, r16
     c70:	0e 94 1c 05 	call	0xa38	; 0xa38 <prvCopyDataToQueue>
     c74:	f8 01       	movw	r30, r16
     c76:	81 89       	ldd	r24, Z+17	; 0x11
     c78:	88 23       	and	r24, r24
     c7a:	41 f0       	breq	.+16     	; 0xc8c <xQueueGenericSend+0x6a>
     c7c:	c8 01       	movw	r24, r16
     c7e:	41 96       	adiw	r24, 0x11	; 17
     c80:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskRemoveFromEventList>
     c84:	81 30       	cpi	r24, 0x01	; 1
     c86:	11 f4       	brne	.+4      	; 0xc8c <xQueueGenericSend+0x6a>
     c88:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
     c8c:	0f 90       	pop	r0
     c8e:	0f be       	out	0x3f, r0	; 63
     c90:	81 e0       	ldi	r24, 0x01	; 1
     c92:	50 c0       	rjmp	.+160    	; 0xd34 <xQueueGenericSend+0x112>
     c94:	8c 81       	ldd	r24, Y+4	; 0x04
     c96:	9d 81       	ldd	r25, Y+5	; 0x05
     c98:	89 2b       	or	r24, r25
     c9a:	21 f4       	brne	.+8      	; 0xca4 <xQueueGenericSend+0x82>
     c9c:	0f 90       	pop	r0
     c9e:	0f be       	out	0x3f, r0	; 63
     ca0:	80 e0       	ldi	r24, 0x00	; 0
     ca2:	48 c0       	rjmp	.+144    	; 0xd34 <xQueueGenericSend+0x112>
     ca4:	b1 10       	cpse	r11, r1
     ca6:	05 c0       	rjmp	.+10     	; 0xcb2 <xQueueGenericSend+0x90>
     ca8:	ce 01       	movw	r24, r28
     caa:	01 96       	adiw	r24, 0x01	; 1
     cac:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vTaskSetTimeOutState>
     cb0:	ba 2c       	mov	r11, r10
     cb2:	0f 90       	pop	r0
     cb4:	0f be       	out	0x3f, r0	; 63
     cb6:	0e 94 10 09 	call	0x1220	; 0x1220 <vTaskSuspendAll>
     cba:	0f b6       	in	r0, 0x3f	; 63
     cbc:	f8 94       	cli
     cbe:	0f 92       	push	r0
     cc0:	f8 01       	movw	r30, r16
     cc2:	85 8d       	ldd	r24, Z+29	; 0x1d
     cc4:	8f 3f       	cpi	r24, 0xFF	; 255
     cc6:	09 f4       	brne	.+2      	; 0xcca <xQueueGenericSend+0xa8>
     cc8:	15 8e       	std	Z+29, r1	; 0x1d
     cca:	f8 01       	movw	r30, r16
     ccc:	86 8d       	ldd	r24, Z+30	; 0x1e
     cce:	8f 3f       	cpi	r24, 0xFF	; 255
     cd0:	09 f4       	brne	.+2      	; 0xcd4 <xQueueGenericSend+0xb2>
     cd2:	16 8e       	std	Z+30, r1	; 0x1e
     cd4:	0f 90       	pop	r0
     cd6:	0f be       	out	0x3f, r0	; 63
     cd8:	be 01       	movw	r22, r28
     cda:	6c 5f       	subi	r22, 0xFC	; 252
     cdc:	7f 4f       	sbci	r23, 0xFF	; 255
     cde:	ce 01       	movw	r24, r28
     ce0:	01 96       	adiw	r24, 0x01	; 1
     ce2:	0e 94 cd 0b 	call	0x179a	; 0x179a <xTaskCheckForTimeOut>
     ce6:	81 11       	cpse	r24, r1
     ce8:	1f c0       	rjmp	.+62     	; 0xd28 <xQueueGenericSend+0x106>
     cea:	0f b6       	in	r0, 0x3f	; 63
     cec:	f8 94       	cli
     cee:	0f 92       	push	r0
     cf0:	f8 01       	movw	r30, r16
     cf2:	92 8d       	ldd	r25, Z+26	; 0x1a
     cf4:	0f 90       	pop	r0
     cf6:	0f be       	out	0x3f, r0	; 63
     cf8:	83 8d       	ldd	r24, Z+27	; 0x1b
     cfa:	98 13       	cpse	r25, r24
     cfc:	0f c0       	rjmp	.+30     	; 0xd1c <xQueueGenericSend+0xfa>
     cfe:	6c 81       	ldd	r22, Y+4	; 0x04
     d00:	7d 81       	ldd	r23, Y+5	; 0x05
     d02:	c7 01       	movw	r24, r14
     d04:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <vTaskPlaceOnEventList>
     d08:	c8 01       	movw	r24, r16
     d0a:	0e 94 77 05 	call	0xaee	; 0xaee <prvUnlockQueue>
     d0e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
     d12:	81 11       	cpse	r24, r1
     d14:	a2 cf       	rjmp	.-188    	; 0xc5a <xQueueGenericSend+0x38>
     d16:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
     d1a:	9f cf       	rjmp	.-194    	; 0xc5a <xQueueGenericSend+0x38>
     d1c:	c8 01       	movw	r24, r16
     d1e:	0e 94 77 05 	call	0xaee	; 0xaee <prvUnlockQueue>
     d22:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
     d26:	99 cf       	rjmp	.-206    	; 0xc5a <xQueueGenericSend+0x38>
     d28:	c8 01       	movw	r24, r16
     d2a:	0e 94 77 05 	call	0xaee	; 0xaee <prvUnlockQueue>
     d2e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
     d32:	80 e0       	ldi	r24, 0x00	; 0
     d34:	0f 90       	pop	r0
     d36:	0f 90       	pop	r0
     d38:	0f 90       	pop	r0
     d3a:	0f 90       	pop	r0
     d3c:	0f 90       	pop	r0
     d3e:	df 91       	pop	r29
     d40:	cf 91       	pop	r28
     d42:	1f 91       	pop	r17
     d44:	0f 91       	pop	r16
     d46:	ff 90       	pop	r15
     d48:	ef 90       	pop	r14
     d4a:	df 90       	pop	r13
     d4c:	cf 90       	pop	r12
     d4e:	bf 90       	pop	r11
     d50:	af 90       	pop	r10
     d52:	9f 90       	pop	r9
     d54:	08 95       	ret

00000d56 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
     d56:	9f 92       	push	r9
     d58:	af 92       	push	r10
     d5a:	bf 92       	push	r11
     d5c:	cf 92       	push	r12
     d5e:	df 92       	push	r13
     d60:	ef 92       	push	r14
     d62:	ff 92       	push	r15
     d64:	0f 93       	push	r16
     d66:	1f 93       	push	r17
     d68:	cf 93       	push	r28
     d6a:	df 93       	push	r29
     d6c:	00 d0       	rcall	.+0      	; 0xd6e <xQueueGenericReceive+0x18>
     d6e:	00 d0       	rcall	.+0      	; 0xd70 <xQueueGenericReceive+0x1a>
     d70:	1f 92       	push	r1
     d72:	cd b7       	in	r28, 0x3d	; 61
     d74:	de b7       	in	r29, 0x3e	; 62
     d76:	8c 01       	movw	r16, r24
     d78:	6b 01       	movw	r12, r22
     d7a:	5d 83       	std	Y+5, r21	; 0x05
     d7c:	4c 83       	std	Y+4, r20	; 0x04
     d7e:	92 2e       	mov	r9, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
     d80:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     d82:	aa 24       	eor	r10, r10
     d84:	a3 94       	inc	r10
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     d86:	7c 01       	movw	r14, r24
     d88:	81 e1       	ldi	r24, 0x11	; 17
     d8a:	e8 0e       	add	r14, r24
     d8c:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     d8e:	0f b6       	in	r0, 0x3f	; 63
     d90:	f8 94       	cli
     d92:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
     d94:	f8 01       	movw	r30, r16
     d96:	82 8d       	ldd	r24, Z+26	; 0x1a
     d98:	88 23       	and	r24, r24
     d9a:	49 f1       	breq	.+82     	; 0xdee <xQueueGenericReceive+0x98>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
     d9c:	e6 80       	ldd	r14, Z+6	; 0x06
     d9e:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     da0:	b6 01       	movw	r22, r12
     da2:	c8 01       	movw	r24, r16
     da4:	0e 94 5d 05 	call	0xaba	; 0xaba <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     da8:	91 10       	cpse	r9, r1
     daa:	10 c0       	rjmp	.+32     	; 0xdcc <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
     dac:	f8 01       	movw	r30, r16
     dae:	82 8d       	ldd	r24, Z+26	; 0x1a
     db0:	81 50       	subi	r24, 0x01	; 1
     db2:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     db4:	80 85       	ldd	r24, Z+8	; 0x08
     db6:	88 23       	and	r24, r24
     db8:	b1 f0       	breq	.+44     	; 0xde6 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     dba:	c8 01       	movw	r24, r16
     dbc:	08 96       	adiw	r24, 0x08	; 8
     dbe:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskRemoveFromEventList>
     dc2:	81 30       	cpi	r24, 0x01	; 1
     dc4:	81 f4       	brne	.+32     	; 0xde6 <xQueueGenericReceive+0x90>
						{
							portYIELD_WITHIN_API();
     dc6:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
     dca:	0d c0       	rjmp	.+26     	; 0xde6 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
     dcc:	f8 01       	movw	r30, r16
     dce:	f7 82       	std	Z+7, r15	; 0x07
     dd0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     dd2:	81 89       	ldd	r24, Z+17	; 0x11
     dd4:	88 23       	and	r24, r24
     dd6:	39 f0       	breq	.+14     	; 0xde6 <xQueueGenericReceive+0x90>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     dd8:	c8 01       	movw	r24, r16
     dda:	41 96       	adiw	r24, 0x11	; 17
     ddc:	0e 94 7d 0b 	call	0x16fa	; 0x16fa <xTaskRemoveFromEventList>
     de0:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
     de2:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
     de6:	0f 90       	pop	r0
     de8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     dea:	81 e0       	ldi	r24, 0x01	; 1
     dec:	4f c0       	rjmp	.+158    	; 0xe8c <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
     dee:	8c 81       	ldd	r24, Y+4	; 0x04
     df0:	9d 81       	ldd	r25, Y+5	; 0x05
     df2:	89 2b       	or	r24, r25
     df4:	21 f4       	brne	.+8      	; 0xdfe <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     df6:	0f 90       	pop	r0
     df8:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     dfa:	80 e0       	ldi	r24, 0x00	; 0
     dfc:	47 c0       	rjmp	.+142    	; 0xe8c <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     dfe:	b1 10       	cpse	r11, r1
     e00:	05 c0       	rjmp	.+10     	; 0xe0c <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     e02:	ce 01       	movw	r24, r28
     e04:	01 96       	adiw	r24, 0x01	; 1
     e06:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     e0a:	ba 2c       	mov	r11, r10
				}
			}
		}
		taskEXIT_CRITICAL();
     e0c:	0f 90       	pop	r0
     e0e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     e10:	0e 94 10 09 	call	0x1220	; 0x1220 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     e14:	0f b6       	in	r0, 0x3f	; 63
     e16:	f8 94       	cli
     e18:	0f 92       	push	r0
     e1a:	f8 01       	movw	r30, r16
     e1c:	85 8d       	ldd	r24, Z+29	; 0x1d
     e1e:	8f 3f       	cpi	r24, 0xFF	; 255
     e20:	09 f4       	brne	.+2      	; 0xe24 <xQueueGenericReceive+0xce>
     e22:	15 8e       	std	Z+29, r1	; 0x1d
     e24:	f8 01       	movw	r30, r16
     e26:	86 8d       	ldd	r24, Z+30	; 0x1e
     e28:	8f 3f       	cpi	r24, 0xFF	; 255
     e2a:	09 f4       	brne	.+2      	; 0xe2e <xQueueGenericReceive+0xd8>
     e2c:	16 8e       	std	Z+30, r1	; 0x1e
     e2e:	0f 90       	pop	r0
     e30:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     e32:	be 01       	movw	r22, r28
     e34:	6c 5f       	subi	r22, 0xFC	; 252
     e36:	7f 4f       	sbci	r23, 0xFF	; 255
     e38:	ce 01       	movw	r24, r28
     e3a:	01 96       	adiw	r24, 0x01	; 1
     e3c:	0e 94 cd 0b 	call	0x179a	; 0x179a <xTaskCheckForTimeOut>
     e40:	81 11       	cpse	r24, r1
     e42:	1e c0       	rjmp	.+60     	; 0xe80 <xQueueGenericReceive+0x12a>

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
     e44:	0f b6       	in	r0, 0x3f	; 63
     e46:	f8 94       	cli
     e48:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
     e4a:	f8 01       	movw	r30, r16
     e4c:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
     e4e:	0f 90       	pop	r0
     e50:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     e52:	81 11       	cpse	r24, r1
     e54:	0f c0       	rjmp	.+30     	; 0xe74 <xQueueGenericReceive+0x11e>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     e56:	6c 81       	ldd	r22, Y+4	; 0x04
     e58:	7d 81       	ldd	r23, Y+5	; 0x05
     e5a:	c7 01       	movw	r24, r14
     e5c:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     e60:	c8 01       	movw	r24, r16
     e62:	0e 94 77 05 	call	0xaee	; 0xaee <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     e66:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
     e6a:	81 11       	cpse	r24, r1
     e6c:	90 cf       	rjmp	.-224    	; 0xd8e <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     e6e:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
     e72:	8d cf       	rjmp	.-230    	; 0xd8e <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     e74:	c8 01       	movw	r24, r16
     e76:	0e 94 77 05 	call	0xaee	; 0xaee <prvUnlockQueue>
				( void ) xTaskResumeAll();
     e7a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
     e7e:	87 cf       	rjmp	.-242    	; 0xd8e <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     e80:	c8 01       	movw	r24, r16
     e82:	0e 94 77 05 	call	0xaee	; 0xaee <prvUnlockQueue>
			( void ) xTaskResumeAll();
     e86:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     e8a:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     e8c:	0f 90       	pop	r0
     e8e:	0f 90       	pop	r0
     e90:	0f 90       	pop	r0
     e92:	0f 90       	pop	r0
     e94:	0f 90       	pop	r0
     e96:	df 91       	pop	r29
     e98:	cf 91       	pop	r28
     e9a:	1f 91       	pop	r17
     e9c:	0f 91       	pop	r16
     e9e:	ff 90       	pop	r15
     ea0:	ef 90       	pop	r14
     ea2:	df 90       	pop	r13
     ea4:	cf 90       	pop	r12
     ea6:	bf 90       	pop	r11
     ea8:	af 90       	pop	r10
     eaa:	9f 90       	pop	r9
     eac:	08 95       	ret

00000eae <prvAddCurrentTaskToDelayedList>:
				{
					vTaskSwitchContext();
				}
			}
		}
	}
     eae:	cf 93       	push	r28
     eb0:	df 93       	push	r29
     eb2:	ec 01       	movw	r28, r24
     eb4:	e0 91 52 03 	lds	r30, 0x0352	; 0x800352 <pxCurrentTCB>
     eb8:	f0 91 53 03 	lds	r31, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
     ebc:	93 83       	std	Z+3, r25	; 0x03
     ebe:	82 83       	std	Z+2, r24	; 0x02
     ec0:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
     ec4:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
     ec8:	c8 17       	cp	r28, r24
     eca:	d9 07       	cpc	r29, r25
     ecc:	68 f4       	brcc	.+26     	; 0xee8 <prvAddCurrentTaskToDelayedList+0x3a>
     ece:	60 91 52 03 	lds	r22, 0x0352	; 0x800352 <pxCurrentTCB>
     ed2:	70 91 53 03 	lds	r23, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
     ed6:	80 91 0f 03 	lds	r24, 0x030F	; 0x80030f <pxOverflowDelayedTaskList>
     eda:	90 91 10 03 	lds	r25, 0x0310	; 0x800310 <pxOverflowDelayedTaskList+0x1>
     ede:	6e 5f       	subi	r22, 0xFE	; 254
     ee0:	7f 4f       	sbci	r23, 0xFF	; 255
     ee2:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsert>
     ee6:	17 c0       	rjmp	.+46     	; 0xf16 <prvAddCurrentTaskToDelayedList+0x68>
     ee8:	60 91 52 03 	lds	r22, 0x0352	; 0x800352 <pxCurrentTCB>
     eec:	70 91 53 03 	lds	r23, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
     ef0:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <pxDelayedTaskList>
     ef4:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
     ef8:	6e 5f       	subi	r22, 0xFE	; 254
     efa:	7f 4f       	sbci	r23, 0xFF	; 255
     efc:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsert>
     f00:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
     f04:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     f08:	c8 17       	cp	r28, r24
     f0a:	d9 07       	cpc	r29, r25
     f0c:	20 f4       	brcc	.+8      	; 0xf16 <prvAddCurrentTaskToDelayedList+0x68>
     f0e:	d0 93 61 00 	sts	0x0061, r29	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
     f12:	c0 93 60 00 	sts	0x0060, r28	; 0x800060 <__DATA_REGION_ORIGIN__>
     f16:	df 91       	pop	r29
     f18:	cf 91       	pop	r28
     f1a:	08 95       	ret

00000f1c <xTaskGenericCreate>:
     f1c:	4f 92       	push	r4
     f1e:	5f 92       	push	r5
     f20:	6f 92       	push	r6
     f22:	7f 92       	push	r7
     f24:	8f 92       	push	r8
     f26:	9f 92       	push	r9
     f28:	af 92       	push	r10
     f2a:	bf 92       	push	r11
     f2c:	cf 92       	push	r12
     f2e:	df 92       	push	r13
     f30:	ef 92       	push	r14
     f32:	ff 92       	push	r15
     f34:	0f 93       	push	r16
     f36:	1f 93       	push	r17
     f38:	cf 93       	push	r28
     f3a:	df 93       	push	r29
     f3c:	5c 01       	movw	r10, r24
     f3e:	4b 01       	movw	r8, r22
     f40:	ea 01       	movw	r28, r20
     f42:	29 01       	movw	r4, r18
     f44:	81 e2       	ldi	r24, 0x21	; 33
     f46:	90 e0       	ldi	r25, 0x00	; 0
     f48:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
     f4c:	3c 01       	movw	r6, r24
     f4e:	00 97       	sbiw	r24, 0x00	; 0
     f50:	09 f4       	brne	.+2      	; 0xf54 <xTaskGenericCreate+0x38>
     f52:	e0 c0       	rjmp	.+448    	; 0x1114 <xTaskGenericCreate+0x1f8>
     f54:	c1 14       	cp	r12, r1
     f56:	d1 04       	cpc	r13, r1
     f58:	09 f0       	breq	.+2      	; 0xf5c <xTaskGenericCreate+0x40>
     f5a:	d7 c0       	rjmp	.+430    	; 0x110a <xTaskGenericCreate+0x1ee>
     f5c:	ce 01       	movw	r24, r28
     f5e:	0e 94 59 00 	call	0xb2	; 0xb2 <pvPortMalloc>
     f62:	f3 01       	movw	r30, r6
     f64:	90 8f       	std	Z+24, r25	; 0x18
     f66:	87 8b       	std	Z+23, r24	; 0x17
     f68:	00 97       	sbiw	r24, 0x00	; 0
     f6a:	21 f4       	brne	.+8      	; 0xf74 <xTaskGenericCreate+0x58>
     f6c:	c3 01       	movw	r24, r6
     f6e:	0e 94 7f 00 	call	0xfe	; 0xfe <vPortFree>
     f72:	d0 c0       	rjmp	.+416    	; 0x1114 <xTaskGenericCreate+0x1f8>
     f74:	ae 01       	movw	r20, r28
     f76:	65 ea       	ldi	r22, 0xA5	; 165
     f78:	70 e0       	ldi	r23, 0x00	; 0
     f7a:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <memset>
     f7e:	21 97       	sbiw	r28, 0x01	; 1
     f80:	f3 01       	movw	r30, r6
     f82:	87 89       	ldd	r24, Z+23	; 0x17
     f84:	90 8d       	ldd	r25, Z+24	; 0x18
     f86:	c8 0f       	add	r28, r24
     f88:	d9 1f       	adc	r29, r25
     f8a:	48 e0       	ldi	r20, 0x08	; 8
     f8c:	50 e0       	ldi	r21, 0x00	; 0
     f8e:	b4 01       	movw	r22, r8
     f90:	c3 01       	movw	r24, r6
     f92:	49 96       	adiw	r24, 0x19	; 25
     f94:	0e 94 50 0d 	call	0x1aa0	; 0x1aa0 <strncpy>
     f98:	f3 01       	movw	r30, r6
     f9a:	10 a2       	std	Z+32, r1	; 0x20
     f9c:	10 2f       	mov	r17, r16
     f9e:	05 30       	cpi	r16, 0x05	; 5
     fa0:	08 f0       	brcs	.+2      	; 0xfa4 <xTaskGenericCreate+0x88>
     fa2:	14 e0       	ldi	r17, 0x04	; 4
     fa4:	f3 01       	movw	r30, r6
     fa6:	16 8b       	std	Z+22, r17	; 0x16
     fa8:	63 01       	movw	r12, r6
     faa:	f2 e0       	ldi	r31, 0x02	; 2
     fac:	cf 0e       	add	r12, r31
     fae:	d1 1c       	adc	r13, r1
     fb0:	c6 01       	movw	r24, r12
     fb2:	0e 94 1a 01 	call	0x234	; 0x234 <vListInitialiseItem>
     fb6:	c3 01       	movw	r24, r6
     fb8:	0c 96       	adiw	r24, 0x0c	; 12
     fba:	0e 94 1a 01 	call	0x234	; 0x234 <vListInitialiseItem>
     fbe:	f3 01       	movw	r30, r6
     fc0:	71 86       	std	Z+9, r7	; 0x09
     fc2:	60 86       	std	Z+8, r6	; 0x08
     fc4:	85 e0       	ldi	r24, 0x05	; 5
     fc6:	90 e0       	ldi	r25, 0x00	; 0
     fc8:	81 1b       	sub	r24, r17
     fca:	91 09       	sbc	r25, r1
     fcc:	95 87       	std	Z+13, r25	; 0x0d
     fce:	84 87       	std	Z+12, r24	; 0x0c
     fd0:	73 8a       	std	Z+19, r7	; 0x13
     fd2:	62 8a       	std	Z+18, r6	; 0x12
     fd4:	a2 01       	movw	r20, r4
     fd6:	b5 01       	movw	r22, r10
     fd8:	ce 01       	movw	r24, r28
     fda:	0e 94 fe 03 	call	0x7fc	; 0x7fc <pxPortInitialiseStack>
     fde:	f3 01       	movw	r30, r6
     fe0:	91 83       	std	Z+1, r25	; 0x01
     fe2:	80 83       	st	Z, r24
     fe4:	e1 14       	cp	r14, r1
     fe6:	f1 04       	cpc	r15, r1
     fe8:	19 f0       	breq	.+6      	; 0xff0 <xTaskGenericCreate+0xd4>
     fea:	f7 01       	movw	r30, r14
     fec:	71 82       	std	Z+1, r7	; 0x01
     fee:	60 82       	st	Z, r6
     ff0:	0f b6       	in	r0, 0x3f	; 63
     ff2:	f8 94       	cli
     ff4:	0f 92       	push	r0
     ff6:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <uxCurrentNumberOfTasks>
     ffa:	8f 5f       	subi	r24, 0xFF	; 255
     ffc:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <uxCurrentNumberOfTasks>
    1000:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <pxCurrentTCB>
    1004:	90 91 53 03 	lds	r25, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    1008:	89 2b       	or	r24, r25
    100a:	c9 f5       	brne	.+114    	; 0x107e <xTaskGenericCreate+0x162>
    100c:	70 92 53 03 	sts	0x0353, r7	; 0x800353 <pxCurrentTCB+0x1>
    1010:	60 92 52 03 	sts	0x0352, r6	; 0x800352 <pxCurrentTCB>
    1014:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <uxCurrentNumberOfTasks>
    1018:	81 30       	cpi	r24, 0x01	; 1
    101a:	09 f0       	breq	.+2      	; 0x101e <xTaskGenericCreate+0x102>
    101c:	3f c0       	rjmp	.+126    	; 0x109c <xTaskGenericCreate+0x180>
    101e:	c5 e2       	ldi	r28, 0x25	; 37
    1020:	d3 e0       	ldi	r29, 0x03	; 3
    1022:	0f 2e       	mov	r0, r31
    1024:	f2 e5       	ldi	r31, 0x52	; 82
    1026:	ef 2e       	mov	r14, r31
    1028:	f3 e0       	ldi	r31, 0x03	; 3
    102a:	ff 2e       	mov	r15, r31
    102c:	f0 2d       	mov	r31, r0
    102e:	ce 01       	movw	r24, r28
    1030:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
    1034:	29 96       	adiw	r28, 0x09	; 9
    1036:	ce 15       	cp	r28, r14
    1038:	df 05       	cpc	r29, r15
    103a:	c9 f7       	brne	.-14     	; 0x102e <xTaskGenericCreate+0x112>
    103c:	8c e1       	ldi	r24, 0x1C	; 28
    103e:	93 e0       	ldi	r25, 0x03	; 3
    1040:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
    1044:	83 e1       	ldi	r24, 0x13	; 19
    1046:	93 e0       	ldi	r25, 0x03	; 3
    1048:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
    104c:	86 e0       	ldi	r24, 0x06	; 6
    104e:	93 e0       	ldi	r25, 0x03	; 3
    1050:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
    1054:	8d ef       	ldi	r24, 0xFD	; 253
    1056:	92 e0       	ldi	r25, 0x02	; 2
    1058:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
    105c:	83 ef       	ldi	r24, 0xF3	; 243
    105e:	92 e0       	ldi	r25, 0x02	; 2
    1060:	0e 94 0c 01 	call	0x218	; 0x218 <vListInitialise>
    1064:	8c e1       	ldi	r24, 0x1C	; 28
    1066:	93 e0       	ldi	r25, 0x03	; 3
    1068:	90 93 12 03 	sts	0x0312, r25	; 0x800312 <pxDelayedTaskList+0x1>
    106c:	80 93 11 03 	sts	0x0311, r24	; 0x800311 <pxDelayedTaskList>
    1070:	83 e1       	ldi	r24, 0x13	; 19
    1072:	93 e0       	ldi	r25, 0x03	; 3
    1074:	90 93 10 03 	sts	0x0310, r25	; 0x800310 <pxOverflowDelayedTaskList+0x1>
    1078:	80 93 0f 03 	sts	0x030F, r24	; 0x80030f <pxOverflowDelayedTaskList>
    107c:	0f c0       	rjmp	.+30     	; 0x109c <xTaskGenericCreate+0x180>
    107e:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <xSchedulerRunning>
    1082:	81 11       	cpse	r24, r1
    1084:	0b c0       	rjmp	.+22     	; 0x109c <xTaskGenericCreate+0x180>
    1086:	e0 91 52 03 	lds	r30, 0x0352	; 0x800352 <pxCurrentTCB>
    108a:	f0 91 53 03 	lds	r31, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    108e:	86 89       	ldd	r24, Z+22	; 0x16
    1090:	08 17       	cp	r16, r24
    1092:	20 f0       	brcs	.+8      	; 0x109c <xTaskGenericCreate+0x180>
    1094:	70 92 53 03 	sts	0x0353, r7	; 0x800353 <pxCurrentTCB+0x1>
    1098:	60 92 52 03 	sts	0x0352, r6	; 0x800352 <pxCurrentTCB>
    109c:	f3 01       	movw	r30, r6
    109e:	86 89       	ldd	r24, Z+22	; 0x16
    10a0:	90 91 ef 02 	lds	r25, 0x02EF	; 0x8002ef <uxTopUsedPriority>
    10a4:	98 17       	cp	r25, r24
    10a6:	10 f4       	brcc	.+4      	; 0x10ac <xTaskGenericCreate+0x190>
    10a8:	80 93 ef 02 	sts	0x02EF, r24	; 0x8002ef <uxTopUsedPriority>
    10ac:	90 91 e8 02 	lds	r25, 0x02E8	; 0x8002e8 <uxTaskNumber>
    10b0:	9f 5f       	subi	r25, 0xFF	; 255
    10b2:	90 93 e8 02 	sts	0x02E8, r25	; 0x8002e8 <uxTaskNumber>
    10b6:	90 91 ee 02 	lds	r25, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    10ba:	98 17       	cp	r25, r24
    10bc:	10 f4       	brcc	.+4      	; 0x10c2 <xTaskGenericCreate+0x1a6>
    10be:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxTopReadyPriority>
    10c2:	90 e0       	ldi	r25, 0x00	; 0
    10c4:	9c 01       	movw	r18, r24
    10c6:	22 0f       	add	r18, r18
    10c8:	33 1f       	adc	r19, r19
    10ca:	22 0f       	add	r18, r18
    10cc:	33 1f       	adc	r19, r19
    10ce:	22 0f       	add	r18, r18
    10d0:	33 1f       	adc	r19, r19
    10d2:	82 0f       	add	r24, r18
    10d4:	93 1f       	adc	r25, r19
    10d6:	b6 01       	movw	r22, r12
    10d8:	8b 5d       	subi	r24, 0xDB	; 219
    10da:	9c 4f       	sbci	r25, 0xFC	; 252
    10dc:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
    10e0:	0f 90       	pop	r0
    10e2:	0f be       	out	0x3f, r0	; 63
    10e4:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <xSchedulerRunning>
    10e8:	88 23       	and	r24, r24
    10ea:	59 f0       	breq	.+22     	; 0x1102 <xTaskGenericCreate+0x1e6>
    10ec:	e0 91 52 03 	lds	r30, 0x0352	; 0x800352 <pxCurrentTCB>
    10f0:	f0 91 53 03 	lds	r31, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    10f4:	86 89       	ldd	r24, Z+22	; 0x16
    10f6:	80 17       	cp	r24, r16
    10f8:	30 f4       	brcc	.+12     	; 0x1106 <xTaskGenericCreate+0x1ea>
    10fa:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
    10fe:	81 e0       	ldi	r24, 0x01	; 1
    1100:	0a c0       	rjmp	.+20     	; 0x1116 <xTaskGenericCreate+0x1fa>
    1102:	81 e0       	ldi	r24, 0x01	; 1
    1104:	08 c0       	rjmp	.+16     	; 0x1116 <xTaskGenericCreate+0x1fa>
    1106:	81 e0       	ldi	r24, 0x01	; 1
    1108:	06 c0       	rjmp	.+12     	; 0x1116 <xTaskGenericCreate+0x1fa>
    110a:	fc 01       	movw	r30, r24
    110c:	d0 8e       	std	Z+24, r13	; 0x18
    110e:	c7 8a       	std	Z+23, r12	; 0x17
    1110:	c6 01       	movw	r24, r12
    1112:	30 cf       	rjmp	.-416    	; 0xf74 <xTaskGenericCreate+0x58>
    1114:	8f ef       	ldi	r24, 0xFF	; 255
    1116:	df 91       	pop	r29
    1118:	cf 91       	pop	r28
    111a:	1f 91       	pop	r17
    111c:	0f 91       	pop	r16
    111e:	ff 90       	pop	r15
    1120:	ef 90       	pop	r14
    1122:	df 90       	pop	r13
    1124:	cf 90       	pop	r12
    1126:	bf 90       	pop	r11
    1128:	af 90       	pop	r10
    112a:	9f 90       	pop	r9
    112c:	8f 90       	pop	r8
    112e:	7f 90       	pop	r7
    1130:	6f 90       	pop	r6
    1132:	5f 90       	pop	r5
    1134:	4f 90       	pop	r4
    1136:	08 95       	ret

00001138 <vTaskDelete>:
    1138:	ef 92       	push	r14
    113a:	ff 92       	push	r15
    113c:	0f 93       	push	r16
    113e:	1f 93       	push	r17
    1140:	cf 93       	push	r28
    1142:	df 93       	push	r29
    1144:	ec 01       	movw	r28, r24
    1146:	0f b6       	in	r0, 0x3f	; 63
    1148:	f8 94       	cli
    114a:	0f 92       	push	r0
    114c:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <pxCurrentTCB>
    1150:	90 91 53 03 	lds	r25, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    1154:	8c 17       	cp	r24, r28
    1156:	9d 07       	cpc	r25, r29
    1158:	11 f0       	breq	.+4      	; 0x115e <vTaskDelete+0x26>
    115a:	20 97       	sbiw	r28, 0x00	; 0
    115c:	39 f4       	brne	.+14     	; 0x116c <vTaskDelete+0x34>
    115e:	c0 91 52 03 	lds	r28, 0x0352	; 0x800352 <pxCurrentTCB>
    1162:	d0 91 53 03 	lds	r29, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    1166:	e1 2c       	mov	r14, r1
    1168:	f1 2c       	mov	r15, r1
    116a:	01 c0       	rjmp	.+2      	; 0x116e <vTaskDelete+0x36>
    116c:	7e 01       	movw	r14, r28
    116e:	8e 01       	movw	r16, r28
    1170:	0e 5f       	subi	r16, 0xFE	; 254
    1172:	1f 4f       	sbci	r17, 0xFF	; 255
    1174:	c8 01       	movw	r24, r16
    1176:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    117a:	8c 89       	ldd	r24, Y+20	; 0x14
    117c:	9d 89       	ldd	r25, Y+21	; 0x15
    117e:	89 2b       	or	r24, r25
    1180:	21 f0       	breq	.+8      	; 0x118a <vTaskDelete+0x52>
    1182:	ce 01       	movw	r24, r28
    1184:	0c 96       	adiw	r24, 0x0c	; 12
    1186:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    118a:	b8 01       	movw	r22, r16
    118c:	8d ef       	ldi	r24, 0xFD	; 253
    118e:	92 e0       	ldi	r25, 0x02	; 2
    1190:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
    1194:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxTasksDeleted>
    1198:	8f 5f       	subi	r24, 0xFF	; 255
    119a:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <uxTasksDeleted>
    119e:	80 91 e8 02 	lds	r24, 0x02E8	; 0x8002e8 <uxTaskNumber>
    11a2:	8f 5f       	subi	r24, 0xFF	; 255
    11a4:	80 93 e8 02 	sts	0x02E8, r24	; 0x8002e8 <uxTaskNumber>
    11a8:	0f 90       	pop	r0
    11aa:	0f be       	out	0x3f, r0	; 63
    11ac:	80 91 ed 02 	lds	r24, 0x02ED	; 0x8002ed <xSchedulerRunning>
    11b0:	88 23       	and	r24, r24
    11b2:	21 f0       	breq	.+8      	; 0x11bc <vTaskDelete+0x84>
    11b4:	ef 28       	or	r14, r15
    11b6:	11 f4       	brne	.+4      	; 0x11bc <vTaskDelete+0x84>
    11b8:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
    11bc:	df 91       	pop	r29
    11be:	cf 91       	pop	r28
    11c0:	1f 91       	pop	r17
    11c2:	0f 91       	pop	r16
    11c4:	ff 90       	pop	r15
    11c6:	ef 90       	pop	r14
    11c8:	08 95       	ret

000011ca <vTaskStartScheduler>:
    11ca:	af 92       	push	r10
    11cc:	bf 92       	push	r11
    11ce:	cf 92       	push	r12
    11d0:	df 92       	push	r13
    11d2:	ef 92       	push	r14
    11d4:	ff 92       	push	r15
    11d6:	0f 93       	push	r16
    11d8:	a1 2c       	mov	r10, r1
    11da:	b1 2c       	mov	r11, r1
    11dc:	c1 2c       	mov	r12, r1
    11de:	d1 2c       	mov	r13, r1
    11e0:	e1 2c       	mov	r14, r1
    11e2:	f1 2c       	mov	r15, r1
    11e4:	00 e0       	ldi	r16, 0x00	; 0
    11e6:	20 e0       	ldi	r18, 0x00	; 0
    11e8:	30 e0       	ldi	r19, 0x00	; 0
    11ea:	45 e5       	ldi	r20, 0x55	; 85
    11ec:	50 e0       	ldi	r21, 0x00	; 0
    11ee:	65 e8       	ldi	r22, 0x85	; 133
    11f0:	70 e0       	ldi	r23, 0x00	; 0
    11f2:	83 eb       	ldi	r24, 0xB3	; 179
    11f4:	9a e0       	ldi	r25, 0x0A	; 10
    11f6:	0e 94 8e 07 	call	0xf1c	; 0xf1c <xTaskGenericCreate>
    11fa:	81 30       	cpi	r24, 0x01	; 1
    11fc:	49 f4       	brne	.+18     	; 0x1210 <vTaskStartScheduler+0x46>
    11fe:	f8 94       	cli
    1200:	80 93 ed 02 	sts	0x02ED, r24	; 0x8002ed <xSchedulerRunning>
    1204:	10 92 f1 02 	sts	0x02F1, r1	; 0x8002f1 <xTickCount+0x1>
    1208:	10 92 f0 02 	sts	0x02F0, r1	; 0x8002f0 <xTickCount>
    120c:	0e 94 6a 04 	call	0x8d4	; 0x8d4 <xPortStartScheduler>
    1210:	0f 91       	pop	r16
    1212:	ff 90       	pop	r15
    1214:	ef 90       	pop	r14
    1216:	df 90       	pop	r13
    1218:	cf 90       	pop	r12
    121a:	bf 90       	pop	r11
    121c:	af 90       	pop	r10
    121e:	08 95       	ret

00001220 <vTaskSuspendAll>:
    1220:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <uxSchedulerSuspended>
    1224:	8f 5f       	subi	r24, 0xFF	; 255
    1226:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <uxSchedulerSuspended>
    122a:	08 95       	ret

0000122c <xTaskGetTickCount>:
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	f8 94       	cli
    1230:	0f 92       	push	r0
    1232:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
    1236:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    123a:	0f 90       	pop	r0
    123c:	0f be       	out	0x3f, r0	; 63
    123e:	08 95       	ret

00001240 <vTaskIncrementTick>:
    1240:	0f 93       	push	r16
    1242:	1f 93       	push	r17
    1244:	cf 93       	push	r28
    1246:	df 93       	push	r29
    1248:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <uxSchedulerSuspended>
    124c:	81 11       	cpse	r24, r1
    124e:	b2 c0       	rjmp	.+356    	; 0x13b4 <vTaskIncrementTick+0x174>
    1250:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
    1254:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    1258:	01 96       	adiw	r24, 0x01	; 1
    125a:	90 93 f1 02 	sts	0x02F1, r25	; 0x8002f1 <xTickCount+0x1>
    125e:	80 93 f0 02 	sts	0x02F0, r24	; 0x8002f0 <xTickCount>
    1262:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
    1266:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    126a:	89 2b       	or	r24, r25
    126c:	99 f5       	brne	.+102    	; 0x12d4 <vTaskIncrementTick+0x94>
    126e:	80 91 11 03 	lds	r24, 0x0311	; 0x800311 <pxDelayedTaskList>
    1272:	90 91 12 03 	lds	r25, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    1276:	20 91 0f 03 	lds	r18, 0x030F	; 0x80030f <pxOverflowDelayedTaskList>
    127a:	30 91 10 03 	lds	r19, 0x0310	; 0x800310 <pxOverflowDelayedTaskList+0x1>
    127e:	30 93 12 03 	sts	0x0312, r19	; 0x800312 <pxDelayedTaskList+0x1>
    1282:	20 93 11 03 	sts	0x0311, r18	; 0x800311 <pxDelayedTaskList>
    1286:	90 93 10 03 	sts	0x0310, r25	; 0x800310 <pxOverflowDelayedTaskList+0x1>
    128a:	80 93 0f 03 	sts	0x030F, r24	; 0x80030f <pxOverflowDelayedTaskList>
    128e:	80 91 e9 02 	lds	r24, 0x02E9	; 0x8002e9 <xNumOfOverflows>
    1292:	8f 5f       	subi	r24, 0xFF	; 255
    1294:	80 93 e9 02 	sts	0x02E9, r24	; 0x8002e9 <xNumOfOverflows>
    1298:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <pxDelayedTaskList>
    129c:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    12a0:	80 81       	ld	r24, Z
    12a2:	81 11       	cpse	r24, r1
    12a4:	07 c0       	rjmp	.+14     	; 0x12b4 <vTaskIncrementTick+0x74>
    12a6:	8f ef       	ldi	r24, 0xFF	; 255
    12a8:	9f ef       	ldi	r25, 0xFF	; 255
    12aa:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    12ae:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    12b2:	10 c0       	rjmp	.+32     	; 0x12d4 <vTaskIncrementTick+0x94>
    12b4:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <pxDelayedTaskList>
    12b8:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    12bc:	05 80       	ldd	r0, Z+5	; 0x05
    12be:	f6 81       	ldd	r31, Z+6	; 0x06
    12c0:	e0 2d       	mov	r30, r0
    12c2:	06 80       	ldd	r0, Z+6	; 0x06
    12c4:	f7 81       	ldd	r31, Z+7	; 0x07
    12c6:	e0 2d       	mov	r30, r0
    12c8:	82 81       	ldd	r24, Z+2	; 0x02
    12ca:	93 81       	ldd	r25, Z+3	; 0x03
    12cc:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    12d0:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    12d4:	20 91 f0 02 	lds	r18, 0x02F0	; 0x8002f0 <xTickCount>
    12d8:	30 91 f1 02 	lds	r19, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    12dc:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__DATA_REGION_ORIGIN__>
    12e0:	90 91 61 00 	lds	r25, 0x0061	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    12e4:	28 17       	cp	r18, r24
    12e6:	39 07       	cpc	r19, r25
    12e8:	08 f4       	brcc	.+2      	; 0x12ec <vTaskIncrementTick+0xac>
    12ea:	69 c0       	rjmp	.+210    	; 0x13be <vTaskIncrementTick+0x17e>
    12ec:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <pxDelayedTaskList>
    12f0:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    12f4:	80 81       	ld	r24, Z
    12f6:	88 23       	and	r24, r24
    12f8:	99 f0       	breq	.+38     	; 0x1320 <vTaskIncrementTick+0xe0>
    12fa:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <pxDelayedTaskList>
    12fe:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    1302:	05 80       	ldd	r0, Z+5	; 0x05
    1304:	f6 81       	ldd	r31, Z+6	; 0x06
    1306:	e0 2d       	mov	r30, r0
    1308:	c6 81       	ldd	r28, Z+6	; 0x06
    130a:	d7 81       	ldd	r29, Z+7	; 0x07
    130c:	8a 81       	ldd	r24, Y+2	; 0x02
    130e:	9b 81       	ldd	r25, Y+3	; 0x03
    1310:	20 91 f0 02 	lds	r18, 0x02F0	; 0x8002f0 <xTickCount>
    1314:	30 91 f1 02 	lds	r19, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    1318:	28 17       	cp	r18, r24
    131a:	39 07       	cpc	r19, r25
    131c:	f8 f4       	brcc	.+62     	; 0x135c <vTaskIncrementTick+0x11c>
    131e:	19 c0       	rjmp	.+50     	; 0x1352 <vTaskIncrementTick+0x112>
    1320:	8f ef       	ldi	r24, 0xFF	; 255
    1322:	9f ef       	ldi	r25, 0xFF	; 255
    1324:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1328:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    132c:	48 c0       	rjmp	.+144    	; 0x13be <vTaskIncrementTick+0x17e>
    132e:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <pxDelayedTaskList>
    1332:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    1336:	05 80       	ldd	r0, Z+5	; 0x05
    1338:	f6 81       	ldd	r31, Z+6	; 0x06
    133a:	e0 2d       	mov	r30, r0
    133c:	c6 81       	ldd	r28, Z+6	; 0x06
    133e:	d7 81       	ldd	r29, Z+7	; 0x07
    1340:	8a 81       	ldd	r24, Y+2	; 0x02
    1342:	9b 81       	ldd	r25, Y+3	; 0x03
    1344:	20 91 f0 02 	lds	r18, 0x02F0	; 0x8002f0 <xTickCount>
    1348:	30 91 f1 02 	lds	r19, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    134c:	28 17       	cp	r18, r24
    134e:	39 07       	cpc	r19, r25
    1350:	28 f4       	brcc	.+10     	; 0x135c <vTaskIncrementTick+0x11c>
    1352:	90 93 61 00 	sts	0x0061, r25	; 0x800061 <__DATA_REGION_ORIGIN__+0x1>
    1356:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__DATA_REGION_ORIGIN__>
    135a:	31 c0       	rjmp	.+98     	; 0x13be <vTaskIncrementTick+0x17e>
    135c:	8e 01       	movw	r16, r28
    135e:	0e 5f       	subi	r16, 0xFE	; 254
    1360:	1f 4f       	sbci	r17, 0xFF	; 255
    1362:	c8 01       	movw	r24, r16
    1364:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    1368:	8c 89       	ldd	r24, Y+20	; 0x14
    136a:	9d 89       	ldd	r25, Y+21	; 0x15
    136c:	89 2b       	or	r24, r25
    136e:	21 f0       	breq	.+8      	; 0x1378 <vTaskIncrementTick+0x138>
    1370:	ce 01       	movw	r24, r28
    1372:	0c 96       	adiw	r24, 0x0c	; 12
    1374:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    1378:	8e 89       	ldd	r24, Y+22	; 0x16
    137a:	90 91 ee 02 	lds	r25, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    137e:	98 17       	cp	r25, r24
    1380:	10 f4       	brcc	.+4      	; 0x1386 <vTaskIncrementTick+0x146>
    1382:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxTopReadyPriority>
    1386:	90 e0       	ldi	r25, 0x00	; 0
    1388:	9c 01       	movw	r18, r24
    138a:	22 0f       	add	r18, r18
    138c:	33 1f       	adc	r19, r19
    138e:	22 0f       	add	r18, r18
    1390:	33 1f       	adc	r19, r19
    1392:	22 0f       	add	r18, r18
    1394:	33 1f       	adc	r19, r19
    1396:	82 0f       	add	r24, r18
    1398:	93 1f       	adc	r25, r19
    139a:	b8 01       	movw	r22, r16
    139c:	8b 5d       	subi	r24, 0xDB	; 219
    139e:	9c 4f       	sbci	r25, 0xFC	; 252
    13a0:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
    13a4:	e0 91 11 03 	lds	r30, 0x0311	; 0x800311 <pxDelayedTaskList>
    13a8:	f0 91 12 03 	lds	r31, 0x0312	; 0x800312 <pxDelayedTaskList+0x1>
    13ac:	80 81       	ld	r24, Z
    13ae:	81 11       	cpse	r24, r1
    13b0:	be cf       	rjmp	.-132    	; 0x132e <vTaskIncrementTick+0xee>
    13b2:	b6 cf       	rjmp	.-148    	; 0x1320 <vTaskIncrementTick+0xe0>
    13b4:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <uxMissedTicks>
    13b8:	8f 5f       	subi	r24, 0xFF	; 255
    13ba:	80 93 eb 02 	sts	0x02EB, r24	; 0x8002eb <uxMissedTicks>
    13be:	df 91       	pop	r29
    13c0:	cf 91       	pop	r28
    13c2:	1f 91       	pop	r17
    13c4:	0f 91       	pop	r16
    13c6:	08 95       	ret

000013c8 <xTaskResumeAll>:
    13c8:	cf 92       	push	r12
    13ca:	df 92       	push	r13
    13cc:	ef 92       	push	r14
    13ce:	ff 92       	push	r15
    13d0:	0f 93       	push	r16
    13d2:	1f 93       	push	r17
    13d4:	cf 93       	push	r28
    13d6:	df 93       	push	r29
    13d8:	0f b6       	in	r0, 0x3f	; 63
    13da:	f8 94       	cli
    13dc:	0f 92       	push	r0
    13de:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <uxSchedulerSuspended>
    13e2:	81 50       	subi	r24, 0x01	; 1
    13e4:	80 93 ec 02 	sts	0x02EC, r24	; 0x8002ec <uxSchedulerSuspended>
    13e8:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <uxSchedulerSuspended>
    13ec:	81 11       	cpse	r24, r1
    13ee:	63 c0       	rjmp	.+198    	; 0x14b6 <xTaskResumeAll+0xee>
    13f0:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <uxCurrentNumberOfTasks>
    13f4:	81 11       	cpse	r24, r1
    13f6:	32 c0       	rjmp	.+100    	; 0x145c <xTaskResumeAll+0x94>
    13f8:	61 c0       	rjmp	.+194    	; 0x14bc <xTaskResumeAll+0xf4>
    13fa:	d7 01       	movw	r26, r14
    13fc:	15 96       	adiw	r26, 0x05	; 5
    13fe:	ed 91       	ld	r30, X+
    1400:	fc 91       	ld	r31, X
    1402:	16 97       	sbiw	r26, 0x06	; 6
    1404:	c6 81       	ldd	r28, Z+6	; 0x06
    1406:	d7 81       	ldd	r29, Z+7	; 0x07
    1408:	ce 01       	movw	r24, r28
    140a:	0c 96       	adiw	r24, 0x0c	; 12
    140c:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    1410:	8e 01       	movw	r16, r28
    1412:	0e 5f       	subi	r16, 0xFE	; 254
    1414:	1f 4f       	sbci	r17, 0xFF	; 255
    1416:	c8 01       	movw	r24, r16
    1418:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    141c:	8e 89       	ldd	r24, Y+22	; 0x16
    141e:	90 91 ee 02 	lds	r25, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    1422:	98 17       	cp	r25, r24
    1424:	10 f4       	brcc	.+4      	; 0x142a <xTaskResumeAll+0x62>
    1426:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxTopReadyPriority>
    142a:	90 e0       	ldi	r25, 0x00	; 0
    142c:	9c 01       	movw	r18, r24
    142e:	22 0f       	add	r18, r18
    1430:	33 1f       	adc	r19, r19
    1432:	22 0f       	add	r18, r18
    1434:	33 1f       	adc	r19, r19
    1436:	22 0f       	add	r18, r18
    1438:	33 1f       	adc	r19, r19
    143a:	82 0f       	add	r24, r18
    143c:	93 1f       	adc	r25, r19
    143e:	b8 01       	movw	r22, r16
    1440:	8b 5d       	subi	r24, 0xDB	; 219
    1442:	9c 4f       	sbci	r25, 0xFC	; 252
    1444:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
    1448:	e0 91 52 03 	lds	r30, 0x0352	; 0x800352 <pxCurrentTCB>
    144c:	f0 91 53 03 	lds	r31, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    1450:	9e 89       	ldd	r25, Y+22	; 0x16
    1452:	86 89       	ldd	r24, Z+22	; 0x16
    1454:	98 17       	cp	r25, r24
    1456:	58 f0       	brcs	.+22     	; 0x146e <xTaskResumeAll+0xa6>
    1458:	dc 2c       	mov	r13, r12
    145a:	09 c0       	rjmp	.+18     	; 0x146e <xTaskResumeAll+0xa6>
    145c:	d1 2c       	mov	r13, r1
    145e:	0f 2e       	mov	r0, r31
    1460:	f6 e0       	ldi	r31, 0x06	; 6
    1462:	ef 2e       	mov	r14, r31
    1464:	f3 e0       	ldi	r31, 0x03	; 3
    1466:	ff 2e       	mov	r15, r31
    1468:	f0 2d       	mov	r31, r0
    146a:	cc 24       	eor	r12, r12
    146c:	c3 94       	inc	r12
    146e:	f7 01       	movw	r30, r14
    1470:	80 81       	ld	r24, Z
    1472:	81 11       	cpse	r24, r1
    1474:	c2 cf       	rjmp	.-124    	; 0x13fa <xTaskResumeAll+0x32>
    1476:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <uxMissedTicks>
    147a:	88 23       	and	r24, r24
    147c:	79 f0       	breq	.+30     	; 0x149c <xTaskResumeAll+0xd4>
    147e:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <uxMissedTicks>
    1482:	88 23       	and	r24, r24
    1484:	59 f0       	breq	.+22     	; 0x149c <xTaskResumeAll+0xd4>
    1486:	0e 94 20 09 	call	0x1240	; 0x1240 <vTaskIncrementTick>
    148a:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <uxMissedTicks>
    148e:	81 50       	subi	r24, 0x01	; 1
    1490:	80 93 eb 02 	sts	0x02EB, r24	; 0x8002eb <uxMissedTicks>
    1494:	80 91 eb 02 	lds	r24, 0x02EB	; 0x8002eb <uxMissedTicks>
    1498:	81 11       	cpse	r24, r1
    149a:	f5 cf       	rjmp	.-22     	; 0x1486 <xTaskResumeAll+0xbe>
    149c:	f1 e0       	ldi	r31, 0x01	; 1
    149e:	df 16       	cp	r13, r31
    14a0:	21 f0       	breq	.+8      	; 0x14aa <xTaskResumeAll+0xe2>
    14a2:	80 91 ea 02 	lds	r24, 0x02EA	; 0x8002ea <xMissedYield>
    14a6:	81 30       	cpi	r24, 0x01	; 1
    14a8:	41 f4       	brne	.+16     	; 0x14ba <xTaskResumeAll+0xf2>
    14aa:	10 92 ea 02 	sts	0x02EA, r1	; 0x8002ea <xMissedYield>
    14ae:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
    14b2:	81 e0       	ldi	r24, 0x01	; 1
    14b4:	03 c0       	rjmp	.+6      	; 0x14bc <xTaskResumeAll+0xf4>
    14b6:	80 e0       	ldi	r24, 0x00	; 0
    14b8:	01 c0       	rjmp	.+2      	; 0x14bc <xTaskResumeAll+0xf4>
    14ba:	80 e0       	ldi	r24, 0x00	; 0
    14bc:	0f 90       	pop	r0
    14be:	0f be       	out	0x3f, r0	; 63
    14c0:	df 91       	pop	r29
    14c2:	cf 91       	pop	r28
    14c4:	1f 91       	pop	r17
    14c6:	0f 91       	pop	r16
    14c8:	ff 90       	pop	r15
    14ca:	ef 90       	pop	r14
    14cc:	df 90       	pop	r13
    14ce:	cf 90       	pop	r12
    14d0:	08 95       	ret

000014d2 <vTaskDelayUntil>:
    14d2:	0f 93       	push	r16
    14d4:	1f 93       	push	r17
    14d6:	cf 93       	push	r28
    14d8:	df 93       	push	r29
    14da:	8c 01       	movw	r16, r24
    14dc:	eb 01       	movw	r28, r22
    14de:	0e 94 10 09 	call	0x1220	; 0x1220 <vTaskSuspendAll>
    14e2:	f8 01       	movw	r30, r16
    14e4:	80 81       	ld	r24, Z
    14e6:	91 81       	ldd	r25, Z+1	; 0x01
    14e8:	c8 0f       	add	r28, r24
    14ea:	d9 1f       	adc	r29, r25
    14ec:	20 91 f0 02 	lds	r18, 0x02F0	; 0x8002f0 <xTickCount>
    14f0:	30 91 f1 02 	lds	r19, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    14f4:	28 17       	cp	r18, r24
    14f6:	39 07       	cpc	r19, r25
    14f8:	68 f4       	brcc	.+26     	; 0x1514 <vTaskDelayUntil+0x42>
    14fa:	c8 17       	cp	r28, r24
    14fc:	d9 07       	cpc	r29, r25
    14fe:	50 f5       	brcc	.+84     	; 0x1554 <vTaskDelayUntil+0x82>
    1500:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
    1504:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    1508:	d1 83       	std	Z+1, r29	; 0x01
    150a:	c0 83       	st	Z, r28
    150c:	8c 17       	cp	r24, r28
    150e:	9d 07       	cpc	r25, r29
    1510:	b0 f4       	brcc	.+44     	; 0x153e <vTaskDelayUntil+0x6c>
    1512:	0b c0       	rjmp	.+22     	; 0x152a <vTaskDelayUntil+0x58>
    1514:	c8 17       	cp	r28, r24
    1516:	d9 07       	cpc	r29, r25
    1518:	c8 f0       	brcs	.+50     	; 0x154c <vTaskDelayUntil+0x7a>
    151a:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
    151e:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    1522:	8c 17       	cp	r24, r28
    1524:	9d 07       	cpc	r25, r29
    1526:	90 f0       	brcs	.+36     	; 0x154c <vTaskDelayUntil+0x7a>
    1528:	15 c0       	rjmp	.+42     	; 0x1554 <vTaskDelayUntil+0x82>
    152a:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <pxCurrentTCB>
    152e:	90 91 53 03 	lds	r25, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    1532:	02 96       	adiw	r24, 0x02	; 2
    1534:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    1538:	ce 01       	movw	r24, r28
    153a:	0e 94 57 07 	call	0xeae	; 0xeae <prvAddCurrentTaskToDelayedList>
    153e:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
    1542:	81 11       	cpse	r24, r1
    1544:	0b c0       	rjmp	.+22     	; 0x155c <vTaskDelayUntil+0x8a>
    1546:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
    154a:	08 c0       	rjmp	.+16     	; 0x155c <vTaskDelayUntil+0x8a>
    154c:	f8 01       	movw	r30, r16
    154e:	d1 83       	std	Z+1, r29	; 0x01
    1550:	c0 83       	st	Z, r28
    1552:	eb cf       	rjmp	.-42     	; 0x152a <vTaskDelayUntil+0x58>
    1554:	f8 01       	movw	r30, r16
    1556:	d1 83       	std	Z+1, r29	; 0x01
    1558:	c0 83       	st	Z, r28
    155a:	f1 cf       	rjmp	.-30     	; 0x153e <vTaskDelayUntil+0x6c>
    155c:	df 91       	pop	r29
    155e:	cf 91       	pop	r28
    1560:	1f 91       	pop	r17
    1562:	0f 91       	pop	r16
    1564:	08 95       	ret

00001566 <prvIdleTask>:
    1566:	0d ef       	ldi	r16, 0xFD	; 253
    1568:	12 e0       	ldi	r17, 0x02	; 2
    156a:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxTasksDeleted>
    156e:	88 23       	and	r24, r24
    1570:	49 f1       	breq	.+82     	; 0x15c4 <prvIdleTask+0x5e>
    1572:	0e 94 10 09 	call	0x1220	; 0x1220 <vTaskSuspendAll>
    1576:	d8 01       	movw	r26, r16
    1578:	cc 91       	ld	r28, X
    157a:	0e 94 e4 09 	call	0x13c8	; 0x13c8 <xTaskResumeAll>
    157e:	cc 23       	and	r28, r28
    1580:	09 f1       	breq	.+66     	; 0x15c4 <prvIdleTask+0x5e>
    1582:	0f b6       	in	r0, 0x3f	; 63
    1584:	f8 94       	cli
    1586:	0f 92       	push	r0
    1588:	d8 01       	movw	r26, r16
    158a:	15 96       	adiw	r26, 0x05	; 5
    158c:	ed 91       	ld	r30, X+
    158e:	fc 91       	ld	r31, X
    1590:	16 97       	sbiw	r26, 0x06	; 6
    1592:	c6 81       	ldd	r28, Z+6	; 0x06
    1594:	d7 81       	ldd	r29, Z+7	; 0x07
    1596:	ce 01       	movw	r24, r28
    1598:	02 96       	adiw	r24, 0x02	; 2
    159a:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
    159e:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <uxCurrentNumberOfTasks>
    15a2:	81 50       	subi	r24, 0x01	; 1
    15a4:	80 93 f2 02 	sts	0x02F2, r24	; 0x8002f2 <uxCurrentNumberOfTasks>
    15a8:	80 91 fc 02 	lds	r24, 0x02FC	; 0x8002fc <uxTasksDeleted>
    15ac:	81 50       	subi	r24, 0x01	; 1
    15ae:	80 93 fc 02 	sts	0x02FC, r24	; 0x8002fc <uxTasksDeleted>
    15b2:	0f 90       	pop	r0
    15b4:	0f be       	out	0x3f, r0	; 63
    15b6:	8f 89       	ldd	r24, Y+23	; 0x17
    15b8:	98 8d       	ldd	r25, Y+24	; 0x18
    15ba:	0e 94 7f 00 	call	0xfe	; 0xfe <vPortFree>
    15be:	ce 01       	movw	r24, r28
    15c0:	0e 94 7f 00 	call	0xfe	; 0xfe <vPortFree>
    15c4:	0e 94 9f 04 	call	0x93e	; 0x93e <vPortYield>
    15c8:	d0 cf       	rjmp	.-96     	; 0x156a <prvIdleTask+0x4>

000015ca <vTaskSwitchContext>:
    15ca:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <uxSchedulerSuspended>
    15ce:	81 11       	cpse	r24, r1
    15d0:	13 c0       	rjmp	.+38     	; 0x15f8 <vTaskSwitchContext+0x2e>
    15d2:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    15d6:	90 e0       	ldi	r25, 0x00	; 0
    15d8:	fc 01       	movw	r30, r24
    15da:	ee 0f       	add	r30, r30
    15dc:	ff 1f       	adc	r31, r31
    15de:	ee 0f       	add	r30, r30
    15e0:	ff 1f       	adc	r31, r31
    15e2:	ee 0f       	add	r30, r30
    15e4:	ff 1f       	adc	r31, r31
    15e6:	8e 0f       	add	r24, r30
    15e8:	9f 1f       	adc	r25, r31
    15ea:	fc 01       	movw	r30, r24
    15ec:	eb 5d       	subi	r30, 0xDB	; 219
    15ee:	fc 4f       	sbci	r31, 0xFC	; 252
    15f0:	80 81       	ld	r24, Z
    15f2:	88 23       	and	r24, r24
    15f4:	29 f0       	breq	.+10     	; 0x1600 <vTaskSwitchContext+0x36>
    15f6:	1b c0       	rjmp	.+54     	; 0x162e <vTaskSwitchContext+0x64>
    15f8:	81 e0       	ldi	r24, 0x01	; 1
    15fa:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <xMissedYield>
    15fe:	08 95       	ret
    1600:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    1604:	81 50       	subi	r24, 0x01	; 1
    1606:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxTopReadyPriority>
    160a:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    160e:	90 e0       	ldi	r25, 0x00	; 0
    1610:	fc 01       	movw	r30, r24
    1612:	ee 0f       	add	r30, r30
    1614:	ff 1f       	adc	r31, r31
    1616:	ee 0f       	add	r30, r30
    1618:	ff 1f       	adc	r31, r31
    161a:	ee 0f       	add	r30, r30
    161c:	ff 1f       	adc	r31, r31
    161e:	8e 0f       	add	r24, r30
    1620:	9f 1f       	adc	r25, r31
    1622:	fc 01       	movw	r30, r24
    1624:	eb 5d       	subi	r30, 0xDB	; 219
    1626:	fc 4f       	sbci	r31, 0xFC	; 252
    1628:	80 81       	ld	r24, Z
    162a:	88 23       	and	r24, r24
    162c:	49 f3       	breq	.-46     	; 0x1600 <vTaskSwitchContext+0x36>
    162e:	80 91 ee 02 	lds	r24, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    1632:	90 e0       	ldi	r25, 0x00	; 0
    1634:	9c 01       	movw	r18, r24
    1636:	22 0f       	add	r18, r18
    1638:	33 1f       	adc	r19, r19
    163a:	22 0f       	add	r18, r18
    163c:	33 1f       	adc	r19, r19
    163e:	22 0f       	add	r18, r18
    1640:	33 1f       	adc	r19, r19
    1642:	28 0f       	add	r18, r24
    1644:	39 1f       	adc	r19, r25
    1646:	d9 01       	movw	r26, r18
    1648:	ab 5d       	subi	r26, 0xDB	; 219
    164a:	bc 4f       	sbci	r27, 0xFC	; 252
    164c:	11 96       	adiw	r26, 0x01	; 1
    164e:	ed 91       	ld	r30, X+
    1650:	fc 91       	ld	r31, X
    1652:	12 97       	sbiw	r26, 0x02	; 2
    1654:	02 80       	ldd	r0, Z+2	; 0x02
    1656:	f3 81       	ldd	r31, Z+3	; 0x03
    1658:	e0 2d       	mov	r30, r0
    165a:	12 96       	adiw	r26, 0x02	; 2
    165c:	fc 93       	st	X, r31
    165e:	ee 93       	st	-X, r30
    1660:	11 97       	sbiw	r26, 0x01	; 1
    1662:	28 5d       	subi	r18, 0xD8	; 216
    1664:	3c 4f       	sbci	r19, 0xFC	; 252
    1666:	e2 17       	cp	r30, r18
    1668:	f3 07       	cpc	r31, r19
    166a:	29 f4       	brne	.+10     	; 0x1676 <vTaskSwitchContext+0xac>
    166c:	22 81       	ldd	r18, Z+2	; 0x02
    166e:	33 81       	ldd	r19, Z+3	; 0x03
    1670:	fd 01       	movw	r30, r26
    1672:	32 83       	std	Z+2, r19	; 0x02
    1674:	21 83       	std	Z+1, r18	; 0x01
    1676:	fc 01       	movw	r30, r24
    1678:	ee 0f       	add	r30, r30
    167a:	ff 1f       	adc	r31, r31
    167c:	ee 0f       	add	r30, r30
    167e:	ff 1f       	adc	r31, r31
    1680:	ee 0f       	add	r30, r30
    1682:	ff 1f       	adc	r31, r31
    1684:	8e 0f       	add	r24, r30
    1686:	9f 1f       	adc	r25, r31
    1688:	fc 01       	movw	r30, r24
    168a:	eb 5d       	subi	r30, 0xDB	; 219
    168c:	fc 4f       	sbci	r31, 0xFC	; 252
    168e:	01 80       	ldd	r0, Z+1	; 0x01
    1690:	f2 81       	ldd	r31, Z+2	; 0x02
    1692:	e0 2d       	mov	r30, r0
    1694:	86 81       	ldd	r24, Z+6	; 0x06
    1696:	97 81       	ldd	r25, Z+7	; 0x07
    1698:	90 93 53 03 	sts	0x0353, r25	; 0x800353 <pxCurrentTCB+0x1>
    169c:	80 93 52 03 	sts	0x0352, r24	; 0x800352 <pxCurrentTCB>
    16a0:	08 95       	ret

000016a2 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    16a2:	cf 93       	push	r28
    16a4:	df 93       	push	r29
    16a6:	eb 01       	movw	r28, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    16a8:	60 91 52 03 	lds	r22, 0x0352	; 0x800352 <pxCurrentTCB>
    16ac:	70 91 53 03 	lds	r23, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    16b0:	64 5f       	subi	r22, 0xF4	; 244
    16b2:	7f 4f       	sbci	r23, 0xFF	; 255
    16b4:	0e 94 45 01 	call	0x28a	; 0x28a <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    16b8:	80 91 52 03 	lds	r24, 0x0352	; 0x800352 <pxCurrentTCB>
    16bc:	90 91 53 03 	lds	r25, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    16c0:	02 96       	adiw	r24, 0x02	; 2
    16c2:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    16c6:	cf 3f       	cpi	r28, 0xFF	; 255
    16c8:	8f ef       	ldi	r24, 0xFF	; 255
    16ca:	d8 07       	cpc	r29, r24
    16cc:	59 f4       	brne	.+22     	; 0x16e4 <vTaskPlaceOnEventList+0x42>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    16ce:	60 91 52 03 	lds	r22, 0x0352	; 0x800352 <pxCurrentTCB>
    16d2:	70 91 53 03 	lds	r23, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
    16d6:	6e 5f       	subi	r22, 0xFE	; 254
    16d8:	7f 4f       	sbci	r23, 0xFF	; 255
    16da:	83 ef       	ldi	r24, 0xF3	; 243
    16dc:	92 e0       	ldi	r25, 0x02	; 2
    16de:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
    16e2:	08 c0       	rjmp	.+16     	; 0x16f4 <vTaskPlaceOnEventList+0x52>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    16e4:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <xTickCount>
    16e8:	90 91 f1 02 	lds	r25, 0x02F1	; 0x8002f1 <xTickCount+0x1>
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    16ec:	8c 0f       	add	r24, r28
    16ee:	9d 1f       	adc	r25, r29
    16f0:	0e 94 57 07 	call	0xeae	; 0xeae <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    16f4:	df 91       	pop	r29
    16f6:	cf 91       	pop	r28
    16f8:	08 95       	ret

000016fa <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    16fa:	0f 93       	push	r16
    16fc:	1f 93       	push	r17
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1702:	dc 01       	movw	r26, r24
    1704:	15 96       	adiw	r26, 0x05	; 5
    1706:	ed 91       	ld	r30, X+
    1708:	fc 91       	ld	r31, X
    170a:	16 97       	sbiw	r26, 0x06	; 6
    170c:	c6 81       	ldd	r28, Z+6	; 0x06
    170e:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1710:	8e 01       	movw	r16, r28
    1712:	04 5f       	subi	r16, 0xF4	; 244
    1714:	1f 4f       	sbci	r17, 0xFF	; 255
    1716:	c8 01       	movw	r24, r16
    1718:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    171c:	80 91 ec 02 	lds	r24, 0x02EC	; 0x8002ec <uxSchedulerSuspended>
    1720:	81 11       	cpse	r24, r1
    1722:	1c c0       	rjmp	.+56     	; 0x175c <xTaskRemoveFromEventList+0x62>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1724:	0a 50       	subi	r16, 0x0A	; 10
    1726:	11 09       	sbc	r17, r1
    1728:	c8 01       	movw	r24, r16
    172a:	0e 94 80 01 	call	0x300	; 0x300 <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    172e:	8e 89       	ldd	r24, Y+22	; 0x16
    1730:	90 91 ee 02 	lds	r25, 0x02EE	; 0x8002ee <uxTopReadyPriority>
    1734:	98 17       	cp	r25, r24
    1736:	10 f4       	brcc	.+4      	; 0x173c <xTaskRemoveFromEventList+0x42>
    1738:	80 93 ee 02 	sts	0x02EE, r24	; 0x8002ee <uxTopReadyPriority>
    173c:	90 e0       	ldi	r25, 0x00	; 0
    173e:	9c 01       	movw	r18, r24
    1740:	22 0f       	add	r18, r18
    1742:	33 1f       	adc	r19, r19
    1744:	22 0f       	add	r18, r18
    1746:	33 1f       	adc	r19, r19
    1748:	22 0f       	add	r18, r18
    174a:	33 1f       	adc	r19, r19
    174c:	82 0f       	add	r24, r18
    174e:	93 1f       	adc	r25, r19
    1750:	b8 01       	movw	r22, r16
    1752:	8b 5d       	subi	r24, 0xDB	; 219
    1754:	9c 4f       	sbci	r25, 0xFC	; 252
    1756:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
    175a:	05 c0       	rjmp	.+10     	; 0x1766 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    175c:	b8 01       	movw	r22, r16
    175e:	86 e0       	ldi	r24, 0x06	; 6
    1760:	93 e0       	ldi	r25, 0x03	; 3
    1762:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1766:	e0 91 52 03 	lds	r30, 0x0352	; 0x800352 <pxCurrentTCB>
    176a:	f0 91 53 03 	lds	r31, 0x0353	; 0x800353 <pxCurrentTCB+0x1>
	else
	{
		xReturn = pdFALSE;
	}

	return xReturn;
    176e:	81 e0       	ldi	r24, 0x01	; 1
    1770:	2e 89       	ldd	r18, Y+22	; 0x16
    1772:	96 89       	ldd	r25, Z+22	; 0x16
    1774:	29 17       	cp	r18, r25
    1776:	08 f4       	brcc	.+2      	; 0x177a <xTaskRemoveFromEventList+0x80>
    1778:	80 e0       	ldi	r24, 0x00	; 0
}
    177a:	df 91       	pop	r29
    177c:	cf 91       	pop	r28
    177e:	1f 91       	pop	r17
    1780:	0f 91       	pop	r16
    1782:	08 95       	ret

00001784 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1784:	20 91 e9 02 	lds	r18, 0x02E9	; 0x8002e9 <xNumOfOverflows>
    1788:	fc 01       	movw	r30, r24
    178a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    178c:	20 91 f0 02 	lds	r18, 0x02F0	; 0x8002f0 <xTickCount>
    1790:	30 91 f1 02 	lds	r19, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    1794:	32 83       	std	Z+2, r19	; 0x02
    1796:	21 83       	std	Z+1, r18	; 0x01
    1798:	08 95       	ret

0000179a <xTaskCheckForTimeOut>:
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    179a:	0f b6       	in	r0, 0x3f	; 63
    179c:	f8 94       	cli
    179e:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    17a0:	db 01       	movw	r26, r22
    17a2:	2d 91       	ld	r18, X+
    17a4:	3c 91       	ld	r19, X
    17a6:	2f 3f       	cpi	r18, 0xFF	; 255
    17a8:	bf ef       	ldi	r27, 0xFF	; 255
    17aa:	3b 07       	cpc	r19, r27
    17ac:	69 f1       	breq	.+90     	; 0x1808 <xTaskCheckForTimeOut+0x6e>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    17ae:	40 91 e9 02 	lds	r20, 0x02E9	; 0x8002e9 <xNumOfOverflows>
    17b2:	fc 01       	movw	r30, r24
    17b4:	50 81       	ld	r21, Z
    17b6:	54 17       	cp	r21, r20
    17b8:	51 f0       	breq	.+20     	; 0x17ce <xTaskCheckForTimeOut+0x34>
    17ba:	40 91 f0 02 	lds	r20, 0x02F0	; 0x8002f0 <xTickCount>
    17be:	50 91 f1 02 	lds	r21, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    17c2:	01 80       	ldd	r0, Z+1	; 0x01
    17c4:	f2 81       	ldd	r31, Z+2	; 0x02
    17c6:	e0 2d       	mov	r30, r0
    17c8:	4e 17       	cp	r20, r30
    17ca:	5f 07       	cpc	r21, r31
    17cc:	f8 f4       	brcc	.+62     	; 0x180c <xTaskCheckForTimeOut+0x72>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    17ce:	40 91 f0 02 	lds	r20, 0x02F0	; 0x8002f0 <xTickCount>
    17d2:	50 91 f1 02 	lds	r21, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    17d6:	dc 01       	movw	r26, r24
    17d8:	11 96       	adiw	r26, 0x01	; 1
    17da:	ed 91       	ld	r30, X+
    17dc:	fc 91       	ld	r31, X
    17de:	12 97       	sbiw	r26, 0x02	; 2
    17e0:	4e 1b       	sub	r20, r30
    17e2:	5f 0b       	sbc	r21, r31
    17e4:	42 17       	cp	r20, r18
    17e6:	53 07       	cpc	r21, r19
    17e8:	98 f4       	brcc	.+38     	; 0x1810 <xTaskCheckForTimeOut+0x76>
    17ea:	db 01       	movw	r26, r22
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    17ec:	40 91 f0 02 	lds	r20, 0x02F0	; 0x8002f0 <xTickCount>
    17f0:	50 91 f1 02 	lds	r21, 0x02F1	; 0x8002f1 <xTickCount+0x1>
    17f4:	4e 1b       	sub	r20, r30
    17f6:	5f 0b       	sbc	r21, r31
    17f8:	24 1b       	sub	r18, r20
    17fa:	35 0b       	sbc	r19, r21
    17fc:	2d 93       	st	X+, r18
    17fe:	3c 93       	st	X, r19
			vTaskSetTimeOutState( pxTimeOut );
    1800:	0e 94 c2 0b 	call	0x1784	; 0x1784 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1804:	80 e0       	ldi	r24, 0x00	; 0
    1806:	05 c0       	rjmp	.+10     	; 0x1812 <xTaskCheckForTimeOut+0x78>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1808:	80 e0       	ldi	r24, 0x00	; 0
    180a:	03 c0       	rjmp	.+6      	; 0x1812 <xTaskCheckForTimeOut+0x78>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    180c:	81 e0       	ldi	r24, 0x01	; 1
    180e:	01 c0       	rjmp	.+2      	; 0x1812 <xTaskCheckForTimeOut+0x78>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    1810:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1812:	0f 90       	pop	r0
    1814:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1816:	08 95       	ret

00001818 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
    1818:	81 e0       	ldi	r24, 0x01	; 1
    181a:	80 93 ea 02 	sts	0x02EA, r24	; 0x8002ea <xMissedYield>
    181e:	08 95       	ret

00001820 <__fixunssfsi>:
    1820:	0e 94 84 0c 	call	0x1908	; 0x1908 <__fp_splitA>
    1824:	88 f0       	brcs	.+34     	; 0x1848 <__fixunssfsi+0x28>
    1826:	9f 57       	subi	r25, 0x7F	; 127
    1828:	98 f0       	brcs	.+38     	; 0x1850 <__fixunssfsi+0x30>
    182a:	b9 2f       	mov	r27, r25
    182c:	99 27       	eor	r25, r25
    182e:	b7 51       	subi	r27, 0x17	; 23
    1830:	b0 f0       	brcs	.+44     	; 0x185e <__fixunssfsi+0x3e>
    1832:	e1 f0       	breq	.+56     	; 0x186c <__fixunssfsi+0x4c>
    1834:	66 0f       	add	r22, r22
    1836:	77 1f       	adc	r23, r23
    1838:	88 1f       	adc	r24, r24
    183a:	99 1f       	adc	r25, r25
    183c:	1a f0       	brmi	.+6      	; 0x1844 <__fixunssfsi+0x24>
    183e:	ba 95       	dec	r27
    1840:	c9 f7       	brne	.-14     	; 0x1834 <__fixunssfsi+0x14>
    1842:	14 c0       	rjmp	.+40     	; 0x186c <__fixunssfsi+0x4c>
    1844:	b1 30       	cpi	r27, 0x01	; 1
    1846:	91 f0       	breq	.+36     	; 0x186c <__fixunssfsi+0x4c>
    1848:	0e 94 9e 0c 	call	0x193c	; 0x193c <__fp_zero>
    184c:	b1 e0       	ldi	r27, 0x01	; 1
    184e:	08 95       	ret
    1850:	0c 94 9e 0c 	jmp	0x193c	; 0x193c <__fp_zero>
    1854:	67 2f       	mov	r22, r23
    1856:	78 2f       	mov	r23, r24
    1858:	88 27       	eor	r24, r24
    185a:	b8 5f       	subi	r27, 0xF8	; 248
    185c:	39 f0       	breq	.+14     	; 0x186c <__fixunssfsi+0x4c>
    185e:	b9 3f       	cpi	r27, 0xF9	; 249
    1860:	cc f3       	brlt	.-14     	; 0x1854 <__fixunssfsi+0x34>
    1862:	86 95       	lsr	r24
    1864:	77 95       	ror	r23
    1866:	67 95       	ror	r22
    1868:	b3 95       	inc	r27
    186a:	d9 f7       	brne	.-10     	; 0x1862 <__fixunssfsi+0x42>
    186c:	3e f4       	brtc	.+14     	; 0x187c <__fixunssfsi+0x5c>
    186e:	90 95       	com	r25
    1870:	80 95       	com	r24
    1872:	70 95       	com	r23
    1874:	61 95       	neg	r22
    1876:	7f 4f       	sbci	r23, 0xFF	; 255
    1878:	8f 4f       	sbci	r24, 0xFF	; 255
    187a:	9f 4f       	sbci	r25, 0xFF	; 255
    187c:	08 95       	ret

0000187e <__floatunsisf>:
    187e:	e8 94       	clt
    1880:	09 c0       	rjmp	.+18     	; 0x1894 <__floatsisf+0x12>

00001882 <__floatsisf>:
    1882:	97 fb       	bst	r25, 7
    1884:	3e f4       	brtc	.+14     	; 0x1894 <__floatsisf+0x12>
    1886:	90 95       	com	r25
    1888:	80 95       	com	r24
    188a:	70 95       	com	r23
    188c:	61 95       	neg	r22
    188e:	7f 4f       	sbci	r23, 0xFF	; 255
    1890:	8f 4f       	sbci	r24, 0xFF	; 255
    1892:	9f 4f       	sbci	r25, 0xFF	; 255
    1894:	99 23       	and	r25, r25
    1896:	a9 f0       	breq	.+42     	; 0x18c2 <__floatsisf+0x40>
    1898:	f9 2f       	mov	r31, r25
    189a:	96 e9       	ldi	r25, 0x96	; 150
    189c:	bb 27       	eor	r27, r27
    189e:	93 95       	inc	r25
    18a0:	f6 95       	lsr	r31
    18a2:	87 95       	ror	r24
    18a4:	77 95       	ror	r23
    18a6:	67 95       	ror	r22
    18a8:	b7 95       	ror	r27
    18aa:	f1 11       	cpse	r31, r1
    18ac:	f8 cf       	rjmp	.-16     	; 0x189e <__floatsisf+0x1c>
    18ae:	fa f4       	brpl	.+62     	; 0x18ee <__floatsisf+0x6c>
    18b0:	bb 0f       	add	r27, r27
    18b2:	11 f4       	brne	.+4      	; 0x18b8 <__floatsisf+0x36>
    18b4:	60 ff       	sbrs	r22, 0
    18b6:	1b c0       	rjmp	.+54     	; 0x18ee <__floatsisf+0x6c>
    18b8:	6f 5f       	subi	r22, 0xFF	; 255
    18ba:	7f 4f       	sbci	r23, 0xFF	; 255
    18bc:	8f 4f       	sbci	r24, 0xFF	; 255
    18be:	9f 4f       	sbci	r25, 0xFF	; 255
    18c0:	16 c0       	rjmp	.+44     	; 0x18ee <__floatsisf+0x6c>
    18c2:	88 23       	and	r24, r24
    18c4:	11 f0       	breq	.+4      	; 0x18ca <__floatsisf+0x48>
    18c6:	96 e9       	ldi	r25, 0x96	; 150
    18c8:	11 c0       	rjmp	.+34     	; 0x18ec <__floatsisf+0x6a>
    18ca:	77 23       	and	r23, r23
    18cc:	21 f0       	breq	.+8      	; 0x18d6 <__floatsisf+0x54>
    18ce:	9e e8       	ldi	r25, 0x8E	; 142
    18d0:	87 2f       	mov	r24, r23
    18d2:	76 2f       	mov	r23, r22
    18d4:	05 c0       	rjmp	.+10     	; 0x18e0 <__floatsisf+0x5e>
    18d6:	66 23       	and	r22, r22
    18d8:	71 f0       	breq	.+28     	; 0x18f6 <__floatsisf+0x74>
    18da:	96 e8       	ldi	r25, 0x86	; 134
    18dc:	86 2f       	mov	r24, r22
    18de:	70 e0       	ldi	r23, 0x00	; 0
    18e0:	60 e0       	ldi	r22, 0x00	; 0
    18e2:	2a f0       	brmi	.+10     	; 0x18ee <__floatsisf+0x6c>
    18e4:	9a 95       	dec	r25
    18e6:	66 0f       	add	r22, r22
    18e8:	77 1f       	adc	r23, r23
    18ea:	88 1f       	adc	r24, r24
    18ec:	da f7       	brpl	.-10     	; 0x18e4 <__floatsisf+0x62>
    18ee:	88 0f       	add	r24, r24
    18f0:	96 95       	lsr	r25
    18f2:	87 95       	ror	r24
    18f4:	97 f9       	bld	r25, 7
    18f6:	08 95       	ret

000018f8 <__fp_split3>:
    18f8:	57 fd       	sbrc	r21, 7
    18fa:	90 58       	subi	r25, 0x80	; 128
    18fc:	44 0f       	add	r20, r20
    18fe:	55 1f       	adc	r21, r21
    1900:	59 f0       	breq	.+22     	; 0x1918 <__fp_splitA+0x10>
    1902:	5f 3f       	cpi	r21, 0xFF	; 255
    1904:	71 f0       	breq	.+28     	; 0x1922 <__fp_splitA+0x1a>
    1906:	47 95       	ror	r20

00001908 <__fp_splitA>:
    1908:	88 0f       	add	r24, r24
    190a:	97 fb       	bst	r25, 7
    190c:	99 1f       	adc	r25, r25
    190e:	61 f0       	breq	.+24     	; 0x1928 <__fp_splitA+0x20>
    1910:	9f 3f       	cpi	r25, 0xFF	; 255
    1912:	79 f0       	breq	.+30     	; 0x1932 <__fp_splitA+0x2a>
    1914:	87 95       	ror	r24
    1916:	08 95       	ret
    1918:	12 16       	cp	r1, r18
    191a:	13 06       	cpc	r1, r19
    191c:	14 06       	cpc	r1, r20
    191e:	55 1f       	adc	r21, r21
    1920:	f2 cf       	rjmp	.-28     	; 0x1906 <__fp_split3+0xe>
    1922:	46 95       	lsr	r20
    1924:	f1 df       	rcall	.-30     	; 0x1908 <__fp_splitA>
    1926:	08 c0       	rjmp	.+16     	; 0x1938 <__fp_splitA+0x30>
    1928:	16 16       	cp	r1, r22
    192a:	17 06       	cpc	r1, r23
    192c:	18 06       	cpc	r1, r24
    192e:	99 1f       	adc	r25, r25
    1930:	f1 cf       	rjmp	.-30     	; 0x1914 <__fp_splitA+0xc>
    1932:	86 95       	lsr	r24
    1934:	71 05       	cpc	r23, r1
    1936:	61 05       	cpc	r22, r1
    1938:	08 94       	sec
    193a:	08 95       	ret

0000193c <__fp_zero>:
    193c:	e8 94       	clt

0000193e <__fp_szero>:
    193e:	bb 27       	eor	r27, r27
    1940:	66 27       	eor	r22, r22
    1942:	77 27       	eor	r23, r23
    1944:	cb 01       	movw	r24, r22
    1946:	97 f9       	bld	r25, 7
    1948:	08 95       	ret

0000194a <__mulsf3>:
    194a:	0e 94 b8 0c 	call	0x1970	; 0x1970 <__mulsf3x>
    194e:	0c 94 29 0d 	jmp	0x1a52	; 0x1a52 <__fp_round>
    1952:	0e 94 1b 0d 	call	0x1a36	; 0x1a36 <__fp_pscA>
    1956:	38 f0       	brcs	.+14     	; 0x1966 <__mulsf3+0x1c>
    1958:	0e 94 22 0d 	call	0x1a44	; 0x1a44 <__fp_pscB>
    195c:	20 f0       	brcs	.+8      	; 0x1966 <__mulsf3+0x1c>
    195e:	95 23       	and	r25, r21
    1960:	11 f0       	breq	.+4      	; 0x1966 <__mulsf3+0x1c>
    1962:	0c 94 12 0d 	jmp	0x1a24	; 0x1a24 <__fp_inf>
    1966:	0c 94 18 0d 	jmp	0x1a30	; 0x1a30 <__fp_nan>
    196a:	11 24       	eor	r1, r1
    196c:	0c 94 9f 0c 	jmp	0x193e	; 0x193e <__fp_szero>

00001970 <__mulsf3x>:
    1970:	0e 94 7c 0c 	call	0x18f8	; 0x18f8 <__fp_split3>
    1974:	70 f3       	brcs	.-36     	; 0x1952 <__mulsf3+0x8>

00001976 <__mulsf3_pse>:
    1976:	95 9f       	mul	r25, r21
    1978:	c1 f3       	breq	.-16     	; 0x196a <__mulsf3+0x20>
    197a:	95 0f       	add	r25, r21
    197c:	50 e0       	ldi	r21, 0x00	; 0
    197e:	55 1f       	adc	r21, r21
    1980:	62 9f       	mul	r22, r18
    1982:	f0 01       	movw	r30, r0
    1984:	72 9f       	mul	r23, r18
    1986:	bb 27       	eor	r27, r27
    1988:	f0 0d       	add	r31, r0
    198a:	b1 1d       	adc	r27, r1
    198c:	63 9f       	mul	r22, r19
    198e:	aa 27       	eor	r26, r26
    1990:	f0 0d       	add	r31, r0
    1992:	b1 1d       	adc	r27, r1
    1994:	aa 1f       	adc	r26, r26
    1996:	64 9f       	mul	r22, r20
    1998:	66 27       	eor	r22, r22
    199a:	b0 0d       	add	r27, r0
    199c:	a1 1d       	adc	r26, r1
    199e:	66 1f       	adc	r22, r22
    19a0:	82 9f       	mul	r24, r18
    19a2:	22 27       	eor	r18, r18
    19a4:	b0 0d       	add	r27, r0
    19a6:	a1 1d       	adc	r26, r1
    19a8:	62 1f       	adc	r22, r18
    19aa:	73 9f       	mul	r23, r19
    19ac:	b0 0d       	add	r27, r0
    19ae:	a1 1d       	adc	r26, r1
    19b0:	62 1f       	adc	r22, r18
    19b2:	83 9f       	mul	r24, r19
    19b4:	a0 0d       	add	r26, r0
    19b6:	61 1d       	adc	r22, r1
    19b8:	22 1f       	adc	r18, r18
    19ba:	74 9f       	mul	r23, r20
    19bc:	33 27       	eor	r19, r19
    19be:	a0 0d       	add	r26, r0
    19c0:	61 1d       	adc	r22, r1
    19c2:	23 1f       	adc	r18, r19
    19c4:	84 9f       	mul	r24, r20
    19c6:	60 0d       	add	r22, r0
    19c8:	21 1d       	adc	r18, r1
    19ca:	82 2f       	mov	r24, r18
    19cc:	76 2f       	mov	r23, r22
    19ce:	6a 2f       	mov	r22, r26
    19d0:	11 24       	eor	r1, r1
    19d2:	9f 57       	subi	r25, 0x7F	; 127
    19d4:	50 40       	sbci	r21, 0x00	; 0
    19d6:	9a f0       	brmi	.+38     	; 0x19fe <__mulsf3_pse+0x88>
    19d8:	f1 f0       	breq	.+60     	; 0x1a16 <__mulsf3_pse+0xa0>
    19da:	88 23       	and	r24, r24
    19dc:	4a f0       	brmi	.+18     	; 0x19f0 <__mulsf3_pse+0x7a>
    19de:	ee 0f       	add	r30, r30
    19e0:	ff 1f       	adc	r31, r31
    19e2:	bb 1f       	adc	r27, r27
    19e4:	66 1f       	adc	r22, r22
    19e6:	77 1f       	adc	r23, r23
    19e8:	88 1f       	adc	r24, r24
    19ea:	91 50       	subi	r25, 0x01	; 1
    19ec:	50 40       	sbci	r21, 0x00	; 0
    19ee:	a9 f7       	brne	.-22     	; 0x19da <__mulsf3_pse+0x64>
    19f0:	9e 3f       	cpi	r25, 0xFE	; 254
    19f2:	51 05       	cpc	r21, r1
    19f4:	80 f0       	brcs	.+32     	; 0x1a16 <__mulsf3_pse+0xa0>
    19f6:	0c 94 12 0d 	jmp	0x1a24	; 0x1a24 <__fp_inf>
    19fa:	0c 94 9f 0c 	jmp	0x193e	; 0x193e <__fp_szero>
    19fe:	5f 3f       	cpi	r21, 0xFF	; 255
    1a00:	e4 f3       	brlt	.-8      	; 0x19fa <__mulsf3_pse+0x84>
    1a02:	98 3e       	cpi	r25, 0xE8	; 232
    1a04:	d4 f3       	brlt	.-12     	; 0x19fa <__mulsf3_pse+0x84>
    1a06:	86 95       	lsr	r24
    1a08:	77 95       	ror	r23
    1a0a:	67 95       	ror	r22
    1a0c:	b7 95       	ror	r27
    1a0e:	f7 95       	ror	r31
    1a10:	e7 95       	ror	r30
    1a12:	9f 5f       	subi	r25, 0xFF	; 255
    1a14:	c1 f7       	brne	.-16     	; 0x1a06 <__mulsf3_pse+0x90>
    1a16:	fe 2b       	or	r31, r30
    1a18:	88 0f       	add	r24, r24
    1a1a:	91 1d       	adc	r25, r1
    1a1c:	96 95       	lsr	r25
    1a1e:	87 95       	ror	r24
    1a20:	97 f9       	bld	r25, 7
    1a22:	08 95       	ret

00001a24 <__fp_inf>:
    1a24:	97 f9       	bld	r25, 7
    1a26:	9f 67       	ori	r25, 0x7F	; 127
    1a28:	80 e8       	ldi	r24, 0x80	; 128
    1a2a:	70 e0       	ldi	r23, 0x00	; 0
    1a2c:	60 e0       	ldi	r22, 0x00	; 0
    1a2e:	08 95       	ret

00001a30 <__fp_nan>:
    1a30:	9f ef       	ldi	r25, 0xFF	; 255
    1a32:	80 ec       	ldi	r24, 0xC0	; 192
    1a34:	08 95       	ret

00001a36 <__fp_pscA>:
    1a36:	00 24       	eor	r0, r0
    1a38:	0a 94       	dec	r0
    1a3a:	16 16       	cp	r1, r22
    1a3c:	17 06       	cpc	r1, r23
    1a3e:	18 06       	cpc	r1, r24
    1a40:	09 06       	cpc	r0, r25
    1a42:	08 95       	ret

00001a44 <__fp_pscB>:
    1a44:	00 24       	eor	r0, r0
    1a46:	0a 94       	dec	r0
    1a48:	12 16       	cp	r1, r18
    1a4a:	13 06       	cpc	r1, r19
    1a4c:	14 06       	cpc	r1, r20
    1a4e:	05 06       	cpc	r0, r21
    1a50:	08 95       	ret

00001a52 <__fp_round>:
    1a52:	09 2e       	mov	r0, r25
    1a54:	03 94       	inc	r0
    1a56:	00 0c       	add	r0, r0
    1a58:	11 f4       	brne	.+4      	; 0x1a5e <__fp_round+0xc>
    1a5a:	88 23       	and	r24, r24
    1a5c:	52 f0       	brmi	.+20     	; 0x1a72 <__fp_round+0x20>
    1a5e:	bb 0f       	add	r27, r27
    1a60:	40 f4       	brcc	.+16     	; 0x1a72 <__fp_round+0x20>
    1a62:	bf 2b       	or	r27, r31
    1a64:	11 f4       	brne	.+4      	; 0x1a6a <__fp_round+0x18>
    1a66:	60 ff       	sbrs	r22, 0
    1a68:	04 c0       	rjmp	.+8      	; 0x1a72 <__fp_round+0x20>
    1a6a:	6f 5f       	subi	r22, 0xFF	; 255
    1a6c:	7f 4f       	sbci	r23, 0xFF	; 255
    1a6e:	8f 4f       	sbci	r24, 0xFF	; 255
    1a70:	9f 4f       	sbci	r25, 0xFF	; 255
    1a72:	08 95       	ret

00001a74 <__tablejump2__>:
    1a74:	ee 0f       	add	r30, r30
    1a76:	ff 1f       	adc	r31, r31
    1a78:	05 90       	lpm	r0, Z+
    1a7a:	f4 91       	lpm	r31, Z
    1a7c:	e0 2d       	mov	r30, r0
    1a7e:	09 94       	ijmp

00001a80 <memcpy>:
    1a80:	fb 01       	movw	r30, r22
    1a82:	dc 01       	movw	r26, r24
    1a84:	02 c0       	rjmp	.+4      	; 0x1a8a <memcpy+0xa>
    1a86:	01 90       	ld	r0, Z+
    1a88:	0d 92       	st	X+, r0
    1a8a:	41 50       	subi	r20, 0x01	; 1
    1a8c:	50 40       	sbci	r21, 0x00	; 0
    1a8e:	d8 f7       	brcc	.-10     	; 0x1a86 <memcpy+0x6>
    1a90:	08 95       	ret

00001a92 <memset>:
    1a92:	dc 01       	movw	r26, r24
    1a94:	01 c0       	rjmp	.+2      	; 0x1a98 <memset+0x6>
    1a96:	6d 93       	st	X+, r22
    1a98:	41 50       	subi	r20, 0x01	; 1
    1a9a:	50 40       	sbci	r21, 0x00	; 0
    1a9c:	e0 f7       	brcc	.-8      	; 0x1a96 <memset+0x4>
    1a9e:	08 95       	ret

00001aa0 <strncpy>:
    1aa0:	fb 01       	movw	r30, r22
    1aa2:	dc 01       	movw	r26, r24
    1aa4:	41 50       	subi	r20, 0x01	; 1
    1aa6:	50 40       	sbci	r21, 0x00	; 0
    1aa8:	48 f0       	brcs	.+18     	; 0x1abc <strncpy+0x1c>
    1aaa:	01 90       	ld	r0, Z+
    1aac:	0d 92       	st	X+, r0
    1aae:	00 20       	and	r0, r0
    1ab0:	c9 f7       	brne	.-14     	; 0x1aa4 <strncpy+0x4>
    1ab2:	01 c0       	rjmp	.+2      	; 0x1ab6 <strncpy+0x16>
    1ab4:	1d 92       	st	X+, r1
    1ab6:	41 50       	subi	r20, 0x01	; 1
    1ab8:	50 40       	sbci	r21, 0x00	; 0
    1aba:	e0 f7       	brcc	.-8      	; 0x1ab4 <strncpy+0x14>
    1abc:	08 95       	ret

00001abe <_exit>:
    1abe:	f8 94       	cli

00001ac0 <__stop_program>:
    1ac0:	ff cf       	rjmp	.-2      	; 0x1ac0 <__stop_program>
